{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>prodsys - modeling, simulating and optimizing production systems</p> <p> </p> <p>prodsys is a python package for modeling, simulating and optimizing production systems based on the product, process and resource (PPR) modelling principle. </p>"},{"location":"#installation","title":"Installation","text":"<p>To install the package, run the following command in the terminal:</p> <pre><code>pip install prodsys\n</code></pre> <p>Please note that prodsys is currently only fully compatible with Python 3.11. Other versions might cause some errors.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>The package is designed to be easy to use. The following example shows how to model a simple production system and simulate it. The production system contains a single milling machine that performs milling processes on aluminium housings. The transport is thereby performed by a worker.  At first, just import the express API of <code>prodsys</code>:</p> <pre><code>import prodsys.express as psx\n</code></pre> <p>We now create all components required for describing the production system. At first we define times for all arrival, production and transport processes:</p> <pre><code>milling_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=1, scale=0.1, ID=\"milling_time\")\ntransport_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=0.3, scale=0.2, ID=\"transport_time\")\narrival_time_of_housings = psx.FunctionTimeModel(distribution_function=\"exponential\", location=1.5, ID=\"arrival_time_of_housings\")\n</code></pre> <p>Next, we can define the production and transport process in the system by using the created time models:</p> <pre><code>milling_process = psx.ProductionProcess(milling_time, ID=\"milling_process\")\ntransport_process = psx.TransportProcess(transport_time, ID=\"transport_process\")\n</code></pre> <p>With the processes defined, we can now create the production and transport resources:</p> <pre><code>milling_machine = psx.ProductionResource([milling_process], location=[5, 5], ID=\"milling_machine\")\nworker = psx.TransportResource([transport_process], location=[0, 0], ID=\"worker\")\n</code></pre> <p>Now we define our product, the housing, that is produced in the system. For this example it requires only a single processsing step:</p> <pre><code>housing = psx.Product(process=[milling_process], transport_process=transport_process, ID=\"housing\")\n</code></pre> <p>Only the sources and sinks that are responsible for creating the housing and storing finished housing are missing:</p> <pre><code>source = psx.Source(product=housing, time_model=arrival_time_of_housings, location=[0, 0], ID=\"source\")\nsink = psx.Sink(product=housing, location=[20, 20], ID=\"sink\")\n</code></pre> <p>Finally, we can create our production system, run the simulation for 60 minutes and print aggregated simulation results:</p> <pre><code>production_system = psx.ProductionSystem([milling_machine, worker], [source], [sink])\nproduction_system.run(60)\nproduction_system.runner.print_results()\n</code></pre> <p>As we can see, the system produced 39 parts in this hour with an work in progress (WIP ~ number of products in the system) of 4.125 and utilized the milling machine with 79.69% and the worker for 78.57% at the PR percentage, the rest of the time, both resource are in standby (SB). Note that these results stay the same although there are stochastic processes in the simulation. This is caused by seeding the random number generator with a fixed value. If you want to get different results, just specify another value for <code>seed</code> parameter from the <code>run</code> method.</p> <pre><code>production_system.run(60, seed=1)\nproduction_system.runner.print_results()\n</code></pre> <p>As expected, the performance of the production system changed quite strongly with the new parameters. The system now produces 26 parts in this hour with an work in progress (WIP ~ number of products in the system) of 1.68. As the arrival process of the housing is modelled by an exponential distribution and we only consider 60 minutes of simulation, this is absolutely expected.</p> <p>However, running longer simulations with multiple seeds is absolutely easy with <code>prodsys</code>. We average our results at the end to calculate the WIP to expect by utilizing the post_processor of the runner, which stores all events of a simulation and has many useful methods for analyzing the simulation results:</p> <pre><code>wip_values = []\n\nfor seed in range(5):\n    production_system.run(2000, seed=seed)\n    run_wip = production_system.post_processor.get_aggregated_wip_data()\n    wip_values.append(run_wip)\n\nprint(\"WIP values for the simulation runs:\", wip_values)\n</code></pre> <p>We can analyze these results easily with numpy seeing that the average WIP is 2.835, which is in between the two first runs, which gives us a more realistic expectation of the system's performance.</p> <pre><code>import numpy as np\nwip = np.array(wip_values).mean(axis=0)\nprint(wip)\n</code></pre> <p>These examples only cover the most basic functionalities of <code>prodsys</code>. For more elaborate guides that guide you through more of the package's features, please see the tutorials. For a complete overview of the package's functionality, please see the API reference.</p>"},{"location":"#contributing","title":"Contributing","text":"<p><code>prodsys</code> is a new project and has therefore much room for improvement. Therefore, it would be a pleasure to get feedback or support! If you want to contribute to the package, either create issues on prodsys' github page for discussing new features or contact me directly via github or email.</p>"},{"location":"#license","title":"License","text":"<p>The package is licensed under the MIT license.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We extend our sincere thanks to the German Federal Ministry for Economic Affairs and Climate Action (BMWK) for supporting this research project 13IK001ZF \u201cSoftware-Defined Manufacturing for the automotive and supplying industry  https://www.sdm4fzi.de/\u201d.</p>"},{"location":"API_reference/API_reference_0_overview/","title":"API reference overview","text":"<p>This section contains the API reference for <code>prodsys</code>. The following modules are available:</p> <ul> <li>Models API</li> <li>Adapter</li> <li>Express API</li> <li>Factories</li> <li>Simulation</li> <li>Optimization</li> <li>Control</li> <li>Utils</li> </ul>"},{"location":"API_reference/API_reference_1_Models_API/","title":"prodsys Models API","text":"<p>The <code>prodsys.models</code> package contains the data structures to describe a production system's structure and its performance. These data structures are utilized in prodsys to have a common format for all algorithms in simulation, optimization, and analysis. All of these formats are compatible with the <code>prodsys.express</code> API. However, the conversion works only in one direction: from <code>prodsys.express</code> to <code>prodsys.models</code>. </p> <p>The following modules are available:</p> <ul> <li><code>prodsys.models.core_asset</code>: Contains the abstract base class for data objects.</li> <li><code>prodsys.models.product_data</code>: Contains classes to represent products.</li> <li><code>prodsys.models.performance_data</code>: Contains classes to represent performance data.</li> <li><code>prodsys.models.performance_indicators</code>: Contains classes to represent performance indicators (KPIs).</li> <li><code>prodsys.models.processes_data</code>: Contains classes to represent processes.</li> <li><code>prodsys.models.queue_data</code>: Contains classes to represent queues.</li> <li><code>prodsys.models.resource_data</code>: Contains classes to represent resources.</li> <li><code>prodsys.models.node_data</code>: Contains classes to represent nodes in a link.</li> <li><code>prodsys.models.scenario_data</code>: Contains classes to represent scenario data.</li> <li><code>prodsys.models.sink_data</code>: Contains classes to represent sinks.</li> <li><code>prodsys.models.source_data</code>: Contains classes to represent sources.</li> <li><code>prodsys.models.state_data</code>: Contains classes to represent states.</li> <li><code>prodsys.models.links_data</code>: Contains classes to represent links.</li> <li><code>prodsys.models.time_model_data</code>: Contains classes to represent time models.</li> </ul>"},{"location":"API_reference/API_reference_2_Adapter/","title":"Adapter","text":"<p>Adapter module for prodsys.</p> <p>This module provides aliases and utility functions for working with production system data. It serves as a compatibility layer and provides convenient access to production system functionality.</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.ProductionSystemData","title":"<code>ProductionSystemData</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A ProductionSystemAdapter serves as a n abstract base class of a data container to represent a production system. It is based on the <code>prodsys.models</code> module, but is also compatible with the <code>prodsys.express</code> API. It is used as the basis for all simulation and optimization algorithms in prodsys and comes with complete data validation. Thereby, it is assured that the expected data is used for simulation and optimization. If the data is not valid, an error is raised with information about the reasons for invalidity. The adapter targets easy integration of algorithms with each other in different environments. Therefore, the adapter can even be used for integration of new algorithms by serving as a defined data interface.</p> <p>Attributes:</p> Name Type Description <code>ID</code> <code>str</code> <p>ID of the production system. Defaults to \"\".</p> <code>seed</code> <code>int</code> <p>Seed for the random number generator used in simulation. Defaults to 0.</p> <code>time_model_data</code> <code>List[TIME_MODEL_DATA]</code> <p>List of time models used by the entities in the production system. Defaults to [].</p> <code>state_data</code> <code>List[STATE_DATA_UNION]</code> <p>List of states used by the resources in the production system. Defaults to [].</p> <code>process_data</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of processes required by products and provided by resources in the production system. Defaults to [].</p> <code>port_data</code> <code>List[QUEUE_DATA_UNION]</code> <p>List of ports used by the resources, sources and sinks in the production system. Defaults to [].</p> <code>node_data</code> <code>List[NodeData]</code> <p>List of nodes in the production system. Defaults to [].</p> <code>resource_data</code> <code>List[ResourceData]</code> <p>List of resources in the production system. Defaults to [].</p> <code>product_data</code> <code>List[ProductData]</code> <p>List of products in the production system. Defaults to [].</p> <code>sink_data</code> <code>List[SinkData]</code> <p>List of sinks in the production system. Defaults to [].</p> <code>source_data</code> <code>List[SOURCE_DATA_UNION]</code> <p>List of sources in the production system. Defaults to [].</p> <code>scenario_data</code> <code>Optional[ScenarioData]</code> <p>Scenario data of the production system used for optimization. Defaults to None.</p> <code>dependency_data</code> <code>Optional[List[DEPENDENCY_TYPES]]</code> <p>List of dependencies in the production system. Defaults to [].</p> <code>primitive_data</code> <code>Optional[List[StoredPrimitive]]</code> <p>List of stored primitives in the production system. Defaults to [].</p> <code>schedule</code> <code>Optional[List[Event]]</code> <p>List of scheduled Events of the production system. Defaults to None.</p> <code>order_data</code> <code>Optional[List[OrderData]]</code> <p>List of orders in the production system. Defaults to None.</p> <code>conwip_number</code> <code>Optional[int]</code> <p>Number of allowed WIP (Work in Progress - number of released products) in the production system. Defaults to None.</p> <code>reference_time</code> <code>Optional[datetime]</code> <p>Reference time of the production system. Defaults to None.</p> <code>time_unit</code> <code>Literal['s', 'min', 'h', 'd']</code> <p>Time unit of the production system. Defaults to \"min\".</p> <code>valid_configuration</code> <code>bool</code> <p>Indicates if the configuration is valid. Defaults to True.</p> <code>reconfiguration_cost</code> <code>float</code> <p>Cost of reconfiguration in a optimization scenario. Defaults to 0.</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.ProductionSystemData.check_no_duplicate_ids","title":"<code>check_no_duplicate_ids()</code>","text":"<p>Validates that no duplicate IDs exist across all data types in the production system. This is critical for proper object resolution, especially for link transport processes.</p> <p>This validator runs automatically: - On initialization of a new ProductionSystemData instance - When entire fields are reassigned (e.g., <code>system.node_data = new_list</code>)</p> <p>For in-place mutations (e.g., <code>system.node_data.append(item)</code>), call <code>revalidate()</code>  or <code>model_validate()</code> explicitly to trigger validation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If duplicate IDs are found with details about which IDs and where.</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.ProductionSystemData.hash","title":"<code>hash()</code>","text":"<p>Generates a hash of the adapter based on the hash of all contained entities. Only information describing the physical structure and functionality of the production system is considered. Can be used to compare two production systems of adapters for functional equality.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hash of the adapter</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.ProductionSystemData.read","title":"<code>read(filepath)</code>  <code>classmethod</code>","text":"<p>Reads a JSON file and returns a ProductionSystemData object.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the JSON file</p> required <p>Returns:</p> Name Type Description <code>ProductionSystemData</code> <code>ProductionSystemData</code> <p>ProductionSystemData object</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.ProductionSystemData.revalidate","title":"<code>revalidate()</code>","text":"<p>Explicitly revalidates the entire ProductionSystemData model.</p> <p>This is useful after making in-place modifications to lists (e.g., appending items) to ensure all validators run, including the duplicate ID check.</p> Example <pre><code>system = ProductionSystemData(...)\nsystem.node_data.append(new_node)  # In-place modification\nsystem.revalidate()  # Trigger validation\n</code></pre> <p>Returns:</p> Name Type Description <code>ProductionSystemData</code> <code>'ProductionSystemData'</code> <p>Self, after validation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If validation fails (e.g., duplicate IDs detected)</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.ProductionSystemData.validate_configuration","title":"<code>validate_configuration()</code>","text":"<p>Checks if the configuration is physically valid, i.e. if all resources are positioned at different locations and if all required processes are available.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If multiple objects are positioned at the same location.</p> <code>ValueError</code> <p>If not all required process are available.</p> <code>ValueError</code> <p>If not all links are available for LinkTransportProcesses.</p> <code>ValueError</code> <p>If ports are missing locations (needed for transport routing).</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.ProductionSystemData.write","title":"<code>write(filepath)</code>","text":"<p>Writes the ProductionSystemData object to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the JSON file</p> required"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.check_for_clean_compound_processes","title":"<code>check_for_clean_compound_processes(adapter_object)</code>","text":"<p>Checks that the compound processes are clean, i.e. that they do not contain compund processes and normal processes at the same time.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_object</code> <code>ProductionSystemAdapter</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the compound processes are clean, False otherwise</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_available_capability_processes","title":"<code>get_available_capability_processes(configuration)</code>","text":"<p>Returns all available capability processes in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of available capability processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_available_process_ids","title":"<code>get_available_process_ids(configuration)</code>","text":"<p>Returns all available process IDs that are used in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of available process IDs</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_available_production_processes","title":"<code>get_available_production_processes(configuration)</code>","text":"<p>Returns all available production processes in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of available production processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_available_transport_processes","title":"<code>get_available_transport_processes(configuration)</code>","text":"<p>Returns all available transport processes in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of available transport processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_conveyor_processes","title":"<code>get_conveyor_processes(configuration)</code>","text":"<p>Returns all required transport processes in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of required transport processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_missing_capability_processes","title":"<code>get_missing_capability_processes(available, required)</code>","text":"<p>Returns list of missing capability processes.</p> <p>Parameters:</p> Name Type Description Default <code>available</code> <code>List[CapabilityProcessData]</code> <p>capability processes that are available in the production system resources</p> required <code>required</code> <code>List[CapabilityProcessData]</code> <p>capability processes that are required from the products</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[CapabilityProcessData]</code> <p>List of missing capability processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_missing_production_processes","title":"<code>get_missing_production_processes(available, required)</code>","text":"<p>Returns list of missing production processes.</p> <p>Parameters:</p> Name Type Description Default <code>available</code> <code>List[ProductionProcessData]</code> <p>production processes that are available in the production system resources</p> required <code>required</code> <code>List[ProductionProcessData]</code> <p>production processes that are required from the products</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[Union[ProductionProcessData, ReworkProcessData]]</code> <p>List of missing production processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_missing_transport_processes","title":"<code>get_missing_transport_processes(available, required)</code>","text":"<p>Returns list of missing transport processes.</p> <p>Parameters:</p> Name Type Description Default <code>available</code> <code>List[TransportProcessData]</code> <p>transport processes that are available in the production system resources</p> required <code>required</code> <code>List[TransportProcessData]</code> <p>transport processes that are required from the products</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[TransportProcessData]</code> <p>List of missing transport processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_production_resources","title":"<code>get_production_resources(adapter)</code>","text":"<p>Returns a list of all machines in the adapter. Resources are considered production resources if they have production or capability processes.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>ProductionSystemAdapter</code> <p>ProductionSystemAdapter object</p> required <p>Returns:</p> Type Description <code>List[ResourceData]</code> <p>List[resource_data_module.ResourceData]: List of all machines in the adapter</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_required_capability_processes","title":"<code>get_required_capability_processes(configuration)</code>","text":"<p>Returns all required capability processes in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of required capability processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_required_process_ids","title":"<code>get_required_process_ids(configuration)</code>","text":"<p>Returns all required process IDs that are used in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of required process IDs</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_required_production_processes","title":"<code>get_required_production_processes(configuration)</code>","text":"<p>Returns all required production processes in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of required production processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_required_transport_processes","title":"<code>get_required_transport_processes(configuration)</code>","text":"<p>Returns all required transport processes in the production system.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>ProductionSystemData</code> <p>Production system configuration</p> required <p>Returns:</p> Name Type Description <code>List</code> <code>List[PROCESS_DATA_UNION]</code> <p>List of required transport processes</p>"},{"location":"API_reference/API_reference_2_Adapter/#prodsys.adapters.get_transport_resources","title":"<code>get_transport_resources(adapter)</code>","text":"<p>Returns a list of all transport resources in the adapter. Resources are considered transport resources if they have transport processes.</p> <p>Parameters:</p> Name Type Description Default <code>adapter</code> <code>ProductionSystemAdapter</code> <p>ProductionSystemAdapter object</p> required <p>Returns:</p> Type Description <code>List[ResourceData]</code> <p>List[resource_data_module.ResourceData]: List of all transport resources in the adapter</p>"},{"location":"API_reference/API_reference_3_Express_API/","title":"prodsys Express API","text":"<p>This module contains the <code>prodsys.express</code> API with classes and functions to easily specify all parameters of a production system. This API is completely compatible with <code>prodsys.models</code> and every object can be converted to a data object from <code>prodsys.models</code> using the <code>to_model</code> method.</p> <p>The express API is more convenient to use than the <code>prodsys.models</code> API because the express API nests the objects in a tree structure, which makes it easier to work with when instantiating production system programatically.</p> <p>However, the express API does not support all features of the <code>prodsys.models</code> API and saved data is more complicated to review because of the nesting.</p> <p>Recommended is to use the API for programmatically specifying a production system but saving the data in the <code>prodsys.models</code> format with the <code>ProductionSystemAdapter</code>.</p> <p>The following modules are available:</p> <ul> <li><code>prodsys.express.core</code>: Contains the abstract base class for express objects.</li> <li><code>prodsys.express.product</code>: Contains classes to specify products.</li> <li><code>prodsys.express.process</code>: Contains classes to specify processes.</li> <li><code>prodsys.express.production_system</code>: Contains classes to specify a production system.</li> <li><code>prodsys.express.resources</code>: Contains classes to specify resources.</li> <li><code>prodsys.express.sink</code>: Contains classes to specify sinks.</li> <li><code>prodsys.express.source</code>: Contains classes to specify sources.</li> <li><code>prodsys.express.state</code>: Contains classes to specify states.</li> <li><code>prodsys.express.time_model</code>: Contains classes to specify time models.</li> </ul>"},{"location":"API_reference/API_reference_4_factories/","title":"Factories","text":"<p>The <code>prodsys.factories</code> package contains the factory classes to create <code>prodsys.simulation</code> objects from <code>prodsys.models</code> objects in order to initialize a simulation run.</p> <p>The following modules are available:</p> <ul> <li><code>prodsys.factories.product_factory</code>: Contains the factory class to create products.</li> <li><code>prodsys.factories.process_factory</code>: Contains the factory class to create processes.</li> <li><code>prodsys.factories.queue_factory</code>: Contains the factory class to create queues.</li> <li><code>prodsys.factories.resource_factory</code>: Contains the factory class to create resources.</li> <li><code>prodsys.factories.sink_factory</code>: Contains the factory class to create sinks.</li> <li><code>prodsys.factories.source_factory</code>: Contains the factory class to create sources.</li> <li><code>prodsys.factories.state_factory</code>: Contains the factory class to create states.</li> <li><code>prodsys.factories.time_model_factory</code>: Contains the factory class to create time models.</li> </ul>"},{"location":"API_reference/API_reference_5_Simulation/","title":"Simulation","text":"<p>This package contains the simulation module. It is based on the SimPy package and uses the <code>prodsys.models</code> API for running the simulation. Objects are created with the <code>prodsys.factories</code>.</p> <p>The simulation module contains the following modules:</p> <ul> <li><code>prodsys.simulation.control</code>: Contains the logic for controlling the processes of resources in the simulation.</li> <li><code>prodsys.simulation.logger</code>: Used for logging events in the simulation for later analysis.</li> <li><code>prodsys.simulation.observer</code>: Can be used to observe the simulation and its processes while simulation.</li> <li><code>prodsys.simulation.process_models</code>: Contains process models for products for the simulation.</li> <li><code>prodsys.simulation.process</code>: All processes used in the simulation for product processing or transport.</li> <li><code>prodsys.simulation.product</code>: Contains the logic for the product object in the simulation.</li> <li><code>prodsys.simulation.request</code>: Has classes for representing requests of products to resources for processing or transport.</li> <li><code>prodsys.simulation.resources</code>: Contains the logic for all resources in the simulation.</li> <li><code>prodsys.simulation.router</code>: Contains the logic for routing products in the simulation.</li> <li><code>prodsys.simulation.sim</code>: Simulation class for running the simulation.</li> <li><code>prodsys.simulation.sink</code>: Contains the logic for sinks in the simulation.</li> <li><code>prodsys.simulation.source</code>: Contains the logic for sources in the simulation.</li> <li><code>prodsys.simulation.state</code>: Contains the logic for the state of resources in the simulation.</li> <li><code>prodsys.simulation.store</code>: Contains the logic for product queues of resources in the simulation.</li> <li><code>prodsys.simulation.time_model</code>: Contains the logic for time models in the simulation.</li> </ul>"},{"location":"API_reference/API_reference_6_Optimization/","title":"Optimization","text":"<p>The <code>optimization</code> package of <code>prodsys</code> provides different optimization algorithms for configuration planning of production systems. </p> <p>In configuration planning, the goal is to find a configuration of a production system that maximizes a given objective function. The objective function is a function that maps a configuration to a real number. The configuration is a set of parameters that describe the production system. For example, the configuration of a production system could be the number of machines of a certain type. The objective function could be the output of the production system. The goal is then to find the configuration that maximizes the output. With <code>prodsys.optimization</code>, you can use the modelling capacities of  <code>prodsys.adapters</code> to specifiy configurations and optimize them according to a scenario and chosen degrees of freedom for optimization.</p> <p>The following degrees of freedom are supported and can be specified by the scenario data attribute <code>transformations</code>:</p> <ul> <li>Adding or removing production resources</li> <li>Adding or removing transport resources</li> <li>Adding or removing processes of a production resource</li> <li>Changing the position of production resources</li> <li>Moving processes between production resources</li> <li>Changing the control policy of a production resource</li> <li>Changing the control policy of a transport resource</li> <li>Changing the routing policy of product types</li> </ul> <p>The following algorithms are supported:</p> <ul> <li>Evolutionary Algorithms (NGSGA-II)</li> <li>Simulated Annealing</li> <li>Tabu Search</li> <li>Mathematical optimization (Gurobi, only a restricted set of degrees of freedom is supported)</li> <li>Capacity-based optimization (fast random search with capacity analysis)</li> </ul> <p>Whilst the mathematical optimization uses a mathematical model for evalutation of production system performance, the other algorithms use <code>prodsys.simulation</code> for evaluation. This allows these algorithms to consider more degrees of freedom and optimize according to multiple objectives.</p> <p>The following KPIs are supported for objectives in optimization with the simulation based optimization algorithms:</p> <ul> <li>Minimize the WIP (Work in Progress)</li> <li>Minimize the throughput time</li> <li>Minimize the reconfiguration cost considering capital expenditure (CAPEX)</li> <li>Maximize the output / throughput</li> </ul> <p>For a more detailed explanation on the algorithms, degrees of freedom and choice of objectives, please consider the following literature: Paper</p>"},{"location":"API_reference/API_reference_6_Optimization/#prodsys.optimization.VERBOSE","title":"<code>VERBOSE = 1</code>  <code>module-attribute</code>","text":"<p>The verbosity level of the optimization algorithms. The higher the level, the more information is printed to the console.</p>"},{"location":"API_reference/API_reference_7_Control/","title":"Control","text":""},{"location":"API_reference/API_reference_8_util/","title":"Util","text":"<p>Contains utility functions for the prodsys package.</p>"},{"location":"Tutorials/tutorial_0_overview/","title":"Tutorials overview","text":"<p>This section contains a series of tutorials that will guide you through the process of modelling and simulating a production system using <code>prodsys</code>. The following tutorials are available:</p>"},{"location":"Tutorials/tutorial_0_overview/#basic-tutorials","title":"Basic Tutorials","text":"<ul> <li>Tutorial 1: Modelling and simulating a production system</li> <li>Tutorial 2: Analyzing simulation results</li> <li>Tutorial 3: Optimizing a production system</li> <li>Tutorial 4: Optimizing production control</li> </ul>"},{"location":"Tutorials/tutorial_0_overview/#advanced-tutorials","title":"Advanced Tutorials","text":"<ul> <li>Tutorial 5: Advanced Dependencies - Learn about ProcessDependency, ResourceDependency, AssemblyDependency, ToolDependency, and LotDependency</li> <li>Tutorial 6: Orders and Schedules - Explore order-based production and schedule-based production control</li> <li>Tutorial 7: System Resources - Model hierarchical production systems with SystemResource</li> </ul> <p>All of the tutorials are also on the github page of prodsys in the examples folder as jupyter notebooks available, so that you can run them yourself.</p> <p>If you have any suggestions for new tutorials, please create an issue on prodsys' github page. For more information about the package's functionality, please see the API reference.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/","title":"Modelling a production system","text":"<p>In this example we explore the modeling functionalities of <code>prodsys</code>. In <code>prodsys</code> we model production systems by specifying the attributes of the following components:</p> <ul> <li>Time model: All relevant timely features of the production system.</li> <li>Processes: Processes give resources the capabilities to perform certain production or transport processes.</li> <li>Resources: Resources perform the production and transport processes.</li> <li>Products: The products that are produced in the production system, requiring a set of processes to be performed.</li> <li>Sources: Sources create products and place them in the production system.</li> <li>Sinks: Sinks store finished products.</li> <li>Production system: The production system is the container for all components and is used to run the simulation.</li> </ul> <p>To make these concepts more understandable, we extend the example from the getting started section. The production system contains a milling machine, a turning lath and a work center that perform processes on aluminium housings. The transport is thereby performed by a worker.</p> <p>We will start by importing the express API:</p> <pre><code>import prodsys.express as psx\n</code></pre> <p>Additionally, since the progress bar can be buggy sometimes in Jupyter notebooks, we can disable it for this example by setting the verbose level of the simulation to 0:</p> <pre><code>from prodsys.simulation import sim\n\nsim.VERBOSE = 0\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#time-models","title":"Time models","text":"<p><code>prodsys</code> provides different types of time models to use, they are:</p> <ul> <li>FunctionTimeModel: A time model that is based on a distribution function. Either constant, normal, lognormal or exponential.</li> <li>SampleTimeModel: A time model that is based on a sequence of time values that are randomly sampled.</li> <li>ScheduledTimeModel: A time model that is based on a schedule of time values. The schedule can contain relative or absolute time values. Also the schedule can be executed once or multiple times in a cycle.</li> <li>DistanceTimeModel: A time model that is based on the distance between two locations and a constant speed and reaction time. Manhattan distance or Euclidian distance can be used as distance metrics between the points.</li> </ul> <p>We will use the <code>FunctionTimeModel</code> to model the time required for milling and turning processes and model the time needed for transport with the <code>DistanceTimeModel</code>. We will also model the arrival of housings with the <code>ScheduledTimeModel</code>, which could, e.g. be observed inter-arrival times:</p> <pre><code>milling_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=1, scale=0.1, ID=\"milling_time\")\nturning_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=0.5, scale=0.1, ID=\"turning_time\")\ntransport_time = psx.DistanceTimeModel(speed=200, reaction_time=0.05, metric=\"manhattan\", ID=\"transport_time\")\narrival_time_of_housing_1 = psx.ScheduledTimeModel([1.6, 1.3, 1.8, 2.0, 1.2, 1.7, 1.3], absolute=False, cyclic=True, ID=\"arrival_time_of_housings\")\narrival_time_of_housing_2 = psx.ScheduledTimeModel([1.3, 2.3, 2.1, 2.0, 1.4], absolute=False, cyclic=True, ID=\"arrival_time_of_housings\")\n</code></pre> <p>Note, the <code>ManhattanDistanceTimeModel</code> and the <code>SequentialTimeModel</code> are deprecated. The <code>ManhattanDistanceTimeModel</code> is replaced by the <code>DistanceTimeModel</code> and the <code>SequentialTimeModel</code> is replaced by the <code>SampleTimeModel</code>.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#processes","title":"Processes","text":"<p>After creating the time models, we can define the processes in the system. We will use the <code>ProductionProcess</code> to model the milling and turning processes and the <code>TransportProcess</code> to model the transport process:</p> <pre><code>milling_process = psx.ProductionProcess(milling_time, ID=\"milling_process\")\nturning_process = psx.ProductionProcess(turning_time, ID=\"turning_process\")\ntransport_process = psx.TransportProcess(transport_time, ID=\"transport_process\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#resources","title":"Resources","text":"<p>With this, we can create our resources. The milling machine and turning lath can perform their associated processes and the worker can perform the transport process. However, the work center can perform milling and turning. Milling machine, turning lath and work center are <code>ProductionResource</code>s and the worker is a <code>TransportResource</code>:</p> <pre><code>milling_machine = psx.ProductionResource([milling_process], location=[5, 5], ID=\"milling_machine\")\nturning_lath = psx.ProductionResource([turning_process], location=[10, 10], ID=\"turning_machine\")\nwork_center = psx.ProductionResource([milling_process, turning_process], location=[5, 10], ID=\"work_center\")\nworker = psx.TransportResource([transport_process], location=[0, 0], ID=\"worker\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#product","title":"Product","text":"<p>Now, with specified resources, we can model our product, the housing. In fact, we don't have only one housing but two different variants for this example. The first product requires milling and afterwards turning, and the second requires turning and afterwards milling:</p> <pre><code>housing_1 = psx.Product(process=[milling_process, turning_process], transport_process=transport_process, ID=\"housing_1\")\nhousing_2 = psx.Product(process=[turning_process, milling_process], transport_process=transport_process, ID=\"housing_2\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#sources-and-sinks","title":"Sources and sinks","text":"<p>At last, we need to model the sources and sinks. The source creates housings and places them in the production system. The sink stores finished housings:</p> <pre><code>source_1 = psx.Source(product=housing_1, time_model=arrival_time_of_housing_1, location=[0,0], ID=\"source_1\")\nsource_2 = psx.Source(product=housing_2, time_model=arrival_time_of_housing_2, location=[0, 1], ID=\"source_2\")\n\nsink_1 = psx.Sink(product=housing_1, location=[20, 20], ID=\"sink_1\")\nsink_2 = psx.Sink(product=housing_2, location=[20, 21], ID=\"sink_2\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#production-system-creation","title":"Production System creation","text":"<p>We now create the production system, validate it and run the simulation for 60 minutes. Afterwards, we print aggregated simulation results:</p> <pre><code>production_system = psx.ProductionSystem([milling_machine, turning_lath, work_center, worker], [source_1, source_2], [sink_1, sink_2])\nproduction_system.validate()\nproduction_system.run(60)\nproduction_system.runner.print_results()\n</code></pre> <p>By validating the production system, we can check if all components are valid and if the production system is consistent in a logical or physical sense. If the production system is not valid, the validation will raise an exception and the simulation cannot be run. However, it easily lets you identify where you made some modelling mistakes.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#states","title":"States","text":"<p>We can also add different states, such as setups and breakdowns, to resources to model their behavior more accurately. For example, we can add a setup and breakdown to the work center by specifying the time models for breakdown and setup, create states and add them to the work center:</p> <pre><code>breakdown_time_model = psx.FunctionTimeModel(distribution_function=\"exponential\", location=200, ID=\"breakdown_time_model\")\nrepair_time_model = psx.FunctionTimeModel(distribution_function=\"exponential\", location=10, ID=\"repair_time_model\")\nsetup_time_model_1 = psx.FunctionTimeModel(distribution_function=\"exponential\", location=0.2, ID=\"setup_time_model\")\nsetup_time_model_2 = psx.FunctionTimeModel(distribution_function=\"exponential\", location=0.3, ID=\"setup_time_model\")\n\nbreakdown_state = psx.BreakDownState(breakdown_time_model, repair_time_model, ID=\"breakdown_state\")\nsetup_state_1 = psx.SetupState(setup_time_model_1, milling_process, turning_process, ID=\"setup_state_1\")\nsetup_state_2 = psx.SetupState(setup_time_model_2, turning_process, milling_process, ID=\"setup_state_2\")\n\nwork_center.states = [breakdown_state, setup_state_1, setup_state_2]\n</code></pre> <p>Note, that we could have given these states to the resource already in the initialization. Again, we simulate the production system and evaluate its performance.</p> <pre><code>production_system.validate()\nproduction_system.run(60)\nproduction_system.runner.print_results()\n</code></pre> <p>The results show that the work center is now for some time in Setup (ST).  However, no time increment for unscheduled downtime due to breakdowns (UD) is visible. This is due to the limited simulation time. If we increase the simulation time to 1000 minutes, we can see that the work center is also in unscheduled downtime for some time:</p> <pre><code>production_system.validate()\nproduction_system.run(1000)\nproduction_system.runner.print_results()\n</code></pre> <p>Now we see, that the work center is 6.1% of the time unavailable due to unscheduled downtime.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#changing-the-logic-of-the-production-system","title":"Changing the logic of the production system","text":"<p><code>prodsys</code> does not only allow to change the physical configuration of a production system but also the logic. For example, we can change the logic of the work center by changing its control policy from <code>FIFO</code> (first in first out) to <code>SPT</code> (shortest process time first). By changing this, the work center will now get products from the queue with bias on the short process, which is in our case the turning process:</p> <pre><code>from prodsys.models.resource_data import ResourceControlPolicy\n\nwork_center.control_policy = ResourceControlPolicy.SPT\n\nproduction_system.validate()\nproduction_system.run(1000)\nproduction_system.runner.print_results()\n</code></pre> <p>Additionally, we can change the routing policy in the production system. A routing policy is not used for heuristically solving a sequencing problem as the control policy but for solving the routing problem for parallel redundant resources. In our example, both milling machine and work center provide the milling process. While simulating, we need to have some logic how to decide which product is processed on which resource. By default, the routing policy is <code>random</code>, which means that the routing is randomly chosen. However, we can also change the routing policy to <code>shortest_queue</code>, which means that the product is always routed to the resource with the shortest queue:</p> <pre><code>from prodsys.models.source_data import RoutingHeuristic\n\nsource_1.routing_heuristic = RoutingHeuristic.shortest_queue\n\nproduction_system.validate()\nproduction_system.run(1000)\nproduction_system.runner.print_results()\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#prodsysmodels-api","title":"prodsys.models API","text":"<p>So far, we only studied the express API of <code>prodsys</code>. However, <code>prodsys</code> also provides a more detailed API that allows to model more complex production systems with <code>prodsys.models</code>. The models API uses ID references for connecting the different entities (processes, products, resources etc.) that results in a flat data structure instead of nested hierarchical relationship, as the express API. Whilst the hierarchical structure is easy for programmatically creating production systems, the flat data structure is more convenient for serializing the data, i.e. saving and loading production systems. All algorithms in <code>prodsys</code> use the models API. For luck, all express API objects can be converted to models API objects and vice versa.</p> <pre><code>model_production_system = production_system.to_model()\nprint(model_production_system.process_data[0])\n</code></pre> <p>For now, the express API allows all modeling features as the models API but the creation of products that require processes in a sequence according to an assembly precedence graph. This feature is only available in the models API. For more information, refer to the API reference in the documentation. However, using the algorithms provided by <code>prodsys</code> for optimizing or autonomously controlling a production system requires the models API. For a complete overview of the package's modelling functionalities, please see the API reference.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#advanced-modeling-features","title":"Advanced modeling features","text":""},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#capability-processes","title":"Capability Processes","text":"<p><code>prodsys</code> also provides the possibility for a <code>CapabilityProcess</code> instead of normal <code>ProductionProcess</code>. These processes are not matched by their ID but by their capability, which gives more flexibility in modeling the operations of a production system. </p> <p>The capabilities extends the typical PPR modeling principle (Product, Process and Resource) of <code>prodsys</code> to the Product, Process, Resource and Skill modelling principle PPRS by considering the capabilities / skills required for performing processes. </p> <p>One typical use case where this capability-based modeling is useful is when a product requires a certain process but multiple resources can perform this process with different speeds or capacity.</p> <p>In prodsys, we can realize this by specifying with a <code>RequiredCapabilityProcess</code> for a product which kind of capabilities are required for its production. Additionally, we define multiple different <code>CapabilityProcess</code> for resources that satisfy the capability and therefore can perform the process on the product. During simulation, processes of resources are matched to the required processes based on a comparison of the capability attribute. </p> <p>For example, we could define the following case, where a turning process is required by a product and two machines are available that can perform this process, but with different speeds:</p> <pre><code>import prodsys.express as psx\nfrom prodsys.express import production_system\n\ntime_model_agv = psx.DistanceTimeModel(speed=90, reaction_time=0.2, ID=\"time_model_x\")\ntransport_process = psx.TransportProcess(\n    time_model=time_model_agv, ID=\"transport_process\"\n)\nagv = psx.TransportResource(ID=\"agv\", processes=[transport_process], location=[5, 5])\n\ntime_model_turning_fast = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=6, ID=\"time_model_turning_fast\"\n)\ntime_model_turning_slow = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=9, ID=\"time_model_turning_slow\"\n)\n\ncapability_process_turning_fast = psx.CapabilityProcess(\n    time_model=time_model_turning_fast, capability=\"turning\", ID=\"cp_turning_fast\"\n)\ncapability_process_turning_slow = psx.CapabilityProcess(\n    time_model=time_model_turning_slow, capability=\"turning\", ID=\"cp_turning_slow\"\n)\n\nresource_fast = psx.ProductionResource(\n    ID=\"resource_fast\", processes=[capability_process_turning_fast], location=[5, 0]\n)\nresource_slow = psx.ProductionResource(\n    ID=\"resource_slow\", processes=[capability_process_turning_slow], location=[5, 10]\n)\n\nrequired_capability_process_turning = psx.RequiredCapabilityProcess(\n    capability=\"turning\", ID=\"rcp_turning\"\n)\n\nproduct = psx.Product(\n    process=[required_capability_process_turning],\n    transport_process=transport_process,\n    ID=\"product\"\n)\n\nsource = psx.Source(\n    product=product,\n    time_model=psx.FunctionTimeModel(\n        distribution_function=\"constant\", location=6, ID=\"interarrival_time_model\"\n    ),\n    location=[0, 5],\n    ID=\"source\"\n)\n\nsink = psx.Sink(product=product, location=[10, 5], ID=\"sink\")\n\nsystem = psx.ProductionSystem(\n    resources=[resource_fast, resource_slow, agv], sources=[source], sinks=[sink]\n)\n\nsystem.validate()\nsystem.run(1000)\nsystem.runner.print_results()\n</code></pre> <p>In this example, we model the <code>RequiredCapabilityProcess</code> of the product by stating, it requires the capability \"turning\":</p> <pre><code>required_capability_process_turning = psx.RequiredCapabilityProcess(\n    capability=\"turning\", ID=\"rcp_turning\"\n)\nproduct = psx.Product(\n    process=[required_capability_process_turning],\n    transport_process=transport_process,\n    ID=\"product\"\n)\n</code></pre> <p>Of course, we could extend the process sequence of the product with other processes, both CapabilityProcesses and normal processes.</p> <p>To specify that two resources can perform this process with different speed, we define two time models, two <code>CapabilityProcess</code> with the capability \"turning\" and two <code>ProductionResource</code>s with the processes:</p> <pre><code>time_model_turning_fast = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=6, ID=\"time_model_turning_fast\"\n)\ntime_model_turning_slow = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=9, ID=\"time_model_turning_slow\"\n)\ncapability_process_turning_fast = psx.CapabilityProcess(\n    time_model=time_model_turning_fast, capability=\"turning\", ID=\"cp_turning_fast\"\n)\ncapability_process_turning_slow = psx.CapabilityProcess(\n    time_model=time_model_turning_slow, capability=\"turning\", ID=\"cp_turning_slow\"\n)\n\nresource_fast = psx.ProductionResource(\n    ID=\"resource_fast\", processes=[capability_process_turning_fast], location=[5, 0]\n)\nresource_slow = psx.ProductionResource(\n    ID=\"resource_slow\", processes=[capability_process_turning_slow], location=[5, 10]\n)\n</code></pre> <p>With this, we can achieve that the product is processed on both machines, but with different speeds.</p> <p>Moreover, there also exists a <code>LinkTransportProcess</code> which allows to define that a transport process can only be performed between certain resources. This allows to make transport in <code>prodsys</code> more realistic. </p> <p>For more information, refer to the API reference in the documentation or checkout the examples folder of <code>prodsys</code>.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#further-modeling-concepts","title":"Further modeling concepts","text":"<p>For more complex use cases that need to consider more aspects of a real production system, prodsys contains some handy features. Modeling concepts that are not yet described in the tutorial are:</p> <ul> <li>Queues and Storages: If you need to specifically restrict the size of resources queues or storages that contain products, you can manually define them with the <code>Queue</code>. The queues can be placed at different locations in the production system.</li> <li>Nodes and Links: If you need to model a more complex production system with multiple locations and transport routes, you can use the <code>Node</code> class to define the locations and create links with a <code>LinkTransportProcess</code>.</li> <li>Auxiliaries: If some processes require supportive material (e.g. work piece carriers or tools), you can define them with the <code>Auxiliary</code> class. The auxiliaries can be used to model the transport of supportive material. </li> </ul> <p>Additionally, prodsys provides the possibility to define your own policies that control the decision making in the production system. With this you can integrate your own logic. The policies are: - Routing Policies: You can create a function that orders a list of requests that contain all possibilities for routing a product to possible resources. Index 0 of the list is the first choice, index 1 the second choice and so on. The routing policy can be used to define the routing of products to resources. - Control Policies: You can create a function that orders a list of requests that contain all possibilities for processing a product on a resource. Index 0 of the list is the first choice, index 1 the second choice and so on. The control policy can be used to define the sequence of processing of products on resources.</p> <p>You can extended the default policies of prodsys by creating your own policies. For more information, refer to the API reference in the documentation or checkout the examples folder of prodsys. For more hands-on experience, you can also check out the examples in the prodsys modeling and simulation examples folder.</p>"},{"location":"Tutorials/tutorial_2_analyzing_simulation_results/","title":"Analyzing simulation results","text":"<p>In the following tutorial, we will explore the analysis capabilities of <code>prodsys</code> for examining simulation results. In <code>prodsys</code>, every single event of a simulation run gets tracked and logged, thus allowing to review the complete event log of a simulation run, as in the real world. Similarly, all KPIs can be calculated in the post processing. This allows for a very flexible analysis of the simulation results. <code>prodsys</code> already provides many utility functions for calculating KPIs and plotting the results. In this tutorial, we will explore some of them.</p> <p>For this example, we will use another production system which we will load from a json-file (example_configuration.json), which can be found in the examples folder of prodsys' github page. Download it and store it in the same folder as this notebook. Load the configuration and run a simulation with the following commands:</p> <pre><code>import prodsys\n\nproduction_system = prodsys.adapters.ProductionSystemData()\nproduction_system.read_data('example_configuration.json')\n\nrunner = prodsys.runner.Runner(adapter=production_system)\nrunner.initialize_simulation()\nrunner.run(20000)\nrunner.print_results()\n</code></pre> <p>When reviewing the simulation results, we will see that the production system consists of 4 production resources (R1, R2, R3, R4) and two transport resources (TR1, TR2). Additionally, we see that three different kind of products are produced (product_1, product_2, product_3). When reviewing the KPIs, there doesn't seem to be any problems with the production system. However, this is hard to tell without knowing something about the production system and we will see that there are some problems with the production system, which we will explore in the following.</p> <p>The basic data structure used for logging all events can be accessed by the <code>EventLogger</code> class, which is an attribute of the runner. The logger stores this data in form of dictionaries but we can transform it to a pandas dataframe for more convenient analysis:</p> <pre><code>df = runner.event_logger.get_data_as_dataframe()\ndf.head(10)\n</code></pre> <p>If we have a look at the dataframe, we will see that it contains 8 columns to describe each event:</p> <ul> <li>Time: The time of the event</li> <li>Resource: The resource on which the event occurred</li> <li>State: The state of the resource that changed</li> <li>State Type: The type of the state that changed (e.g. source, transport, breakdown, etc.)</li> <li>Activity: The activity that was performed</li> <li>Product: The product that was processed or transported (only for Production or Transport states)</li> <li>Expected End Time: The expected end time of the state</li> <li>Target location: The target location of a transport (only for Transport states)</li> </ul> <p>Writing scripts that analyze these event logs can be tedious. We can use powerful process mining tools to automate the analysis of these event logs to analyze all processes, event durations and so on. However, in this tutorial, we will focus on the analysis of the KPIs. For this, we will use the <code>PostProcessor</code> class, which can be obtained from runner. The <code>PostProcessor</code> class provides many utility functions for calculating KPIs and plotting the results. In this tutorial, we will explore some of them. Let's get a <code>PostProcessor</code> from the runner and have a look at the KPIs:</p> <pre><code>post_processor = runner.get_post_processor()\nprint(\"Throughput per product type:\", post_processor.get_aggregated_throughput_data())\nprint(\"WIP per product type:\", post_processor.get_aggregated_wip_data())\nprint(\"Throughput time per product type:\", post_processor.get_aggregated_throughput_time_data())\n</code></pre> <p><code>prodsys</code> also provides some models for KPIs which can be used more easily in algorithms. For example, we can use the <code>WIP_KPIs</code>property to calculate the KPI values of the production system:</p> <pre><code>for wip_kpi in post_processor.WIP_KPIs:\n    print(\"WIP KPI:\", wip_kpi)\n    print(\"WIP KPI value:\", wip_kpi.value)\n</code></pre> <p>The <code>PostProcessor</code> has some pre-processed data frames, which can be used for custom analyis. For example, we can get a data frame with only products that have been finished during the simulation run:</p> <pre><code>post_processor.df_finished_product.head()\n</code></pre> <p>However, the easiest or fastest method for analyzing simulation results is using the plotting functionalities of <code>prodsys</code>. These can be accessed through the <code>kpi_visualization</code> and only require a <code>PostProcessor</code> for instantiation. For example, we can plot the time percentages of resources in different states:</p> <pre><code>from prodsys.util import kpi_visualization\n\nkpi_visualization.plot_time_per_state_of_resources(post_processor)\n</code></pre> <p>We can observe, that the resources in the production system are not really heavily utilized, since their productive (PR) percentage is lower than 50% for all resources but R2. Let's plot the WIP KPI and see if this aligns with our first observations:</p> <pre><code>from prodsys.util import kpi_visualization\n\nkpi_visualization.plot_WIP(post_processor)\n</code></pre> <p>We can see that the production system has at first a stable WIP at around a total of 7 but at roughly 5000 minutes, the WIP starts increasing and does not stabilize anymore. This suggest, that our system is running very full with semi-finished material. We can look more closely at the WIP when considering the WIP at the different resources over time:</p> <pre><code>kpi_visualization.plot_WIP_per_resource(post_processor)\n</code></pre> <p>When observing the WIP per resource, we can observe that WIP at the resources increase steadily until ca. 15500 minutes. Then, suddenly, the WIP curve stops. This is a strong indicator that a Deadlock occured, where all positions of the queues are full and transports are blocked, because their target is blocked. This, is caused as products can have re-entrant flow in this example, thus blocking each other. Let's also look at the throughput time of the products:</p> <pre><code>kpi_visualization.plot_throughput_time_over_time(post_processor)\n</code></pre> <p>Again, we see a divergence of throughput time over simulated time. Here, the Start_time relates to the start of production of a product, i.e. the creation at its source. These observations suggest, that the system is running to a WIP level which cannot be processed efficiently, similar to a crowded parking space after an event. If we take a look at the queues of the system and the capacity of production resources, we can determine the maximal number of products in the system:</p> <pre><code>capacity = 0\nfor resource in production_system.resource_data:\n    capacity += resource.capacity\n\nfor queue in production_system.queue_data:\n    capacity += queue.capacity\n\nprint(capacity)\n</code></pre> <p>We see, that at maximum 69 products can be in the production system in parallel. However, when we examine the queues more in detail, we see, that some resource share also queues (R3 and R4):</p> <pre><code>machines = prodsys.adapters.get_machines(production_system)\nfor machine in machines:\n    print(machine.ID, machine.input_queues, machine.output_queues)\n</code></pre> <p>Let's investigate if the production system's storage capacity for products is too low that there is some blocking or if the production system's throughput is not high enough for the arrival processes. To do this, we test how the WIP changes if we make the queues of the production system unlimited (capacity=0).</p> <pre><code>adjusted_production_system = production_system.copy(deep=True)\n\nfor queue in adjusted_production_system.queue_data:\n    queue.capacity = 0\n\nrunner = prodsys.runner.Runner(adapter=adjusted_production_system)\nrunner.initialize_simulation()\nrunner.run(20000)\nnew_post_processor = runner.get_post_processor()\nkpi_visualization.plot_WIP(new_post_processor)\n</code></pre> <p>If we look at the results again, we see that the production system WIP increases not as strong as without limited queues. This suggests that both cases were True. At first, the production system got fuller without limited queues which suggest that some queues overflowed when limited causing some blocking. Additionally, we see that the WIP still increases over time, thus the production system requires more resources or another configuration to satisfy the arrival processes. <code>prodsys</code> provides also some functionality to optimize production system configuration. See the optimization example for more detailed information. For a complete overview of the package's functionalities for simulation analysis, please see the API reference.</p>"},{"location":"Tutorials/tutorial_3_optimizing_a_production_system/","title":"Optimizing a production system","text":"<p>This tutorial will guide you through the optimization functionalities of <code>prodsys</code> to optimize the configuration of a production system. With the <code>prodsys.optimization</code> package, we can utilize meta-heuristics and mathematical optimization for this task. All algorithms can be conveniently used with the <code>prodsys.models</code> API.</p> <p>For this example, we will use a production system which we will load from a json-file (base_configuration.json), which can be found in the examples folder of prodsys' github page. Download it and store it in the same folder as this notebook. Load the configuration and run a simulation with the following commands:</p> <pre><code>import prodsys\nfrom prodsys.simulation import sim\nsim.VERBOSE = 0\n\nproduction_system = prodsys.adapters.ProductionSystemData()\nproduction_system.read_data('base_configuration.json')\n\nprodsys.adapters.add_default_queues_to_adapter(production_system)\n\nrunner = prodsys.runner.Runner(adapter=production_system)\nrunner.initialize_simulation()\nrunner.run(2880)\nrunner.print_results()\n</code></pre> <p>As already concluded in the second tutorial, production system configurations can be suboptimal for a certain load of products. In this example, we also see that resources M2, M3, M4 are very heavily utilized, whereas resource M1 has only a productivity of 34.4%. In order to satisfy the product needs of our customers and to balance the load on the resources more evenly, we want to find a more suitable configuration with the <code>prodsys.optimization</code> package. However, for starting optimization, we also need to provide an optimization scenario, that models constraints, options, information and the objectives. Let's start by creating the constraints of the scenario with the <code>prodsys.models</code> API:</p> <pre><code>from prodsys.models import scenario_data\n\nconstraints = scenario_data.ScenarioConstrainsData(\n    max_reconfiguration_cost=100000,\n    max_num_machines=8,\n    max_num_processes_per_machine=3,\n    max_num_transport_resources=2\n)\n</code></pre> <p>As you can see, the constraints consist of the maximum cost for reconfiguration and the maximum number of machines, processes per machine and transport resources. Next, we define the options of our scenario for optimization:</p> <pre><code>positions = [[x*4, y*4] for x in range(4) for y in range(10)]\noptions = scenario_data.ScenarioOptionsData(\n    transformations=[scenario_data.ReconfigurationEnum.PRODUCTION_CAPACITY],\n    machine_controllers=[\"FIFO\", \"SPT\"],\n    transport_controllers=[\"FIFO\", \"SPT_transport\"],\n    routing_heuristics=[\"shortest_queue\"],\n    positions=positions\n)\n</code></pre> <p>We specify in the scenario options the transformations that can be performed by the optimizer, which control policies and routing heuristics are available and what kind of positions are available to place resources. By choosing the transformation <code>PRODUCTION_CAPACITY</code>, the optimizer can add, remove or move production resources from the system or processes from single production resources.</p> <p>At last, we need to specify our info for optimization:</p> <pre><code>info = scenario_data.ScenarioInfoData(\n    machine_cost=40000,\n    transport_resource_cost=20000,\n    process_module_cost=4000,\n    time_range=24*60\n)\n</code></pre> <p>The scenario info contains information about the cost for machines, transport resources and process modules. Additionally, we specify a time range. This value is the time used for evaluation of created configurations during simulation. Since many evaluations are performed during optimization, this parameter can significantly influence the optimization time. For now, we specified it to one day. Lastly we can define the objectives used for optimization:</p> <pre><code>from prodsys.models.performance_indicators import KPIEnum\nobjectives = [scenario_data.Objective(\n    name=KPIEnum.THROUGHPUT\n)]\n</code></pre> <p>Currently, only reconfiguration cost, throughput time, WIP and throughput can be optimized. Yet, similar logic can also be used for optimizing the productivity. With all this data defined, we can now create our optimization scenario and additionally add it to our production system:</p> <pre><code>scenario = scenario_data.ScenarioData(\n    constraints=constraints,\n    options=options,\n    info=info,\n    objectives=objectives\n)\nproduction_system.scenario_data = scenario\n</code></pre> <p>Instead of calling the optimization algorithms directly, we use the Optimizer class to manage the optimization process. This allows us to run different optimization algorithms within a unified interface while tracking optimization progress in real-time. Next, we define the hyper parameters for our optimization. At first, we will use evolutionary algorithm for our optimization, because it allows parallelization. The hyper parameters for optimization are strongly problem dependent and need to be adjusted accordingly. For this example, we will use the following parameters and run the optimization for 10 generations. Note, that this can take some time...</p> <pre><code>from prodsys.optimization.evolutionary_algorithm import EvolutionaryAlgorithmHyperparameters\nfrom prodsys.optimization.optimizer import FileSystemSaveOptimizer\n\nhyper_parameters = EvolutionaryAlgorithmHyperparameters(\n    seed=0,\n    number_of_generations=10,\n    population_size=16,\n    mutation_rate=0.2,\n    crossover_rate=0.1,\n    number_of_seeds=1,\n    number_of_processes=1\n)\n#Create an optimizer instance\noptimizer = FileSystemSaveOptimizer(\n    adapter=production_system,\n    hyperparameters=hyper_parameters,\n    save_folder=\"optimization_results\",\n)\n#Run the optimization\noptimizer.optimize()\n</code></pre> <p>All algorithms in <code>prodsys</code> can be utilized with the same interface. Also available are the following algorithms:</p> <ul> <li><code>prodsys.optimization.simulated_annealing</code>: simulated annealing optimization for all transformations</li> <li><code>prodsys.optimization.tabu_search</code>: tabu search for all transformations</li> <li><code>prodsys.optimization.math_opt</code>: mathematical optimization with Gurobi, allows only optimization of the production capacity</li> </ul> <p>We see in the output, that the algorithm is running and that new best solutions with a higher performance are found. We can analyze them now and see, if we can find a better configuration for our production system. Optimization core results of the objective for the individual solutions and the solutions themselves are saved in the specified <code>optimization_results</code> folder to make sure that interruptions in optimization won't delete all results. We can load them with the following command and search for the best solution:</p> <pre><code>from prodsys.optimization import optimization_analysis\n\ndf = optimization_analysis.read_optimization_results_file_to_df(\"results/optimization_results.json\", \"evolutionary\")\ndf.sort_values(by=[\"agg_fitness\"], ascending=False).head()\n</code></pre> <p><code>prodsys</code> allows us to load the optimization results as a data frame and analyze them. For validation purposes, we simulate the best solution again and compare it to the initial solutions:</p> <pre><code>import os \n\n# Find all files i the result folder that contain the ID of the best individual\nbest_individual_ID = df.sort_values(by=[\"agg_fitness\"], ascending=False).head()[\"ID\"].values[0]\nbest_individual_ID = str(best_individual_ID)\nfiles = os.listdir(\"results\")\nfiles = [file for file in files if best_individual_ID in file]\nnew_production_system = prodsys.adapters.ProductionSystemData()\nnew_production_system.read_data(\"results/\" + files[0])\n\nrunner = prodsys.runner.Runner(adapter=new_production_system)\nrunner.initialize_simulation()\nrunner.run(2880)\n\nrunner.print_results()\n</code></pre> <p>When comparing the results from the original production system and the new one, we see that two machines were added. However, the machines are still heavily utilized. Most likely, the optimizer did just not find a good solution, because we only ran it for 10 generations and for a small population size. Increasing these will take longer, but will more likely find better solutions.</p> <p>For a complete overview of the package's functionality, please see the API reference.</p>"},{"location":"Tutorials/tutorial_4_optimizing_production_control/","title":"Optimizing production control","text":"<p>This tutorial will guide you through the optimization functionalities of <code>prodsys</code> to optimize the production control in a production system. With the <code>prodsys.control</code> package, we can utilize reinforcement learning, a kind of machine learning, for this task. All algorithms can be conviently used with the <code>prodsys.models</code> API.</p> <p>For this example, we will use again a production system which we will load from a json-file (control_configuration.json), which can be found in the examples folder of prodsys' github page. It is the same example as in tutorial 2, but with lower arrival rates. Download it and store it in the same folder as this notebook. Load the configuration and run a simulation with the following commands:</p> <p>Let's start at first by loading our production system:</p> <pre><code>import prodsys\nfrom prodsys.simulation import sim\nsim.VERBOSE = 0\n\nproduction_system = prodsys.adapters.ProductionSystemData()\nproduction_system.read_data('control_configuration.json')\n\nrunner = prodsys.runner.Runner(adapter=production_system)\nrunner.initialize_simulation()\nrunner.run(2880)\nrunner.print_results()\n</code></pre> <p>When reviewing the performance, we see that resource R2 has the highest productivity. In order to reduce WIP and improve overall performance, we want to optimize the production control concerning R2 with Reinforcement Learning. <code>prodsys.control</code> provides a convenient API to do so, by defining interfaces for training environments for RL agents for production control task. So far, the following elementary control tasks are considered:</p> <ul> <li>Sequencing: The agent has to decide for a resource which product to process next from a list of available products.</li> <li>Routing: The agent determines for a product which resource it processes next, given a list of possible resources to perform this process.</li> </ul> <p>In this tutorial, we will focus on the sequencing task. The routing task is similar and can be used analogously. Note that future versions of <code>prodsys.control</code> will provide more control tasks (e.g. such as product release control) and that it is also possible to define custom control tasks that are a combination of the existing ones.</p>"},{"location":"Tutorials/tutorial_4_optimizing_production_control/#the-training-environment-api","title":"The training environment API","text":"<p>When utilizing reinforcement learning for production control, we need to define a training environment for the RL agent. This environment is responsible for providing the agent with the current state of the production system and for executing the agent's actions. The environment is also responsible for providing the agent with a reward for each action. The gymnasium package is used as a basis for these environments to be compatible with most RL-frameworks available. For more detailed information on the gym-environment API, please read their documentation. Here, we will use stable-baselines3 as RL-framework. The environments provided by <code>prodsys.control</code> are implemented as abstract base classes, specifying the methods that need to be implemented by the user for solving the associated control tasks. To realize a control environment, we need to implement a class that inherits from the abstract base classes and implements its abstract methods:</p> <pre><code>from gymnasium import spaces\nimport numpy as np\nimport prodsys\nfrom prodsys.simulation import request\nfrom prodsys.control import sequencing_control_env\n\nclass ExampleControlEnv(sequencing_control_env.AbstractSequencingControlEnv):\n    def get_observation(self) -&gt; np.ndarray:\n        # Implement here function that returns the observation that fits to the observation space of the class instances.\n        pass\n\n    def get_info(self) -&gt; dict:\n        # Implement here function that returns a dictionary with information about the environment.\n        pass\n\n    def get_termination_condition(self) -&gt; bool:\n        # Implement here function that returns True if the simulation should be terminated, i.e. an episode ends.\n        pass\n\n    def get_reward(self, processed_request: request.Request, invalid_action: bool = False) -&gt; float:\n        # Implement here function that returns the reward for the current step.\n        pass\n</code></pre> <p>So, only 4 functions have to implemented to start training an RL-agent. These functions define the most critical aspects when training an RL-agent, which makes these environments especially easy to experiment with different RL-agent setups and compare them. Simulation interactions are handled by the environment, so that the user can focus on the RL-agent.</p> <p>Especially definitions of observations and rewards are critical for the performance of the agent. The following sections will show an exemplary implementation of the environment for the sequencing task.</p>"},{"location":"Tutorials/tutorial_4_optimizing_production_control/#example-implementation-of-a-sequencing-environment","title":"Example implementation of a sequencing environment","text":"<p>In this example, we will implement the training environment for an RL-agent that determines the sequence of performed processes for the production resource R2 from the example above.</p> <p>For a simple optimization of performed processes, we want that the RL-agent can observe all running processes and all upcoming processes from the queue. We want to motivate the agent to sequence in a way, that the WIP is low and as few as little setups are performed, since this lower throughput.</p> <p>To do so, we define the observation space, to be a binary tensor of shape CxP, where C is the number of possible running processes and the number of slots in the input queue of the resource and P is the number of possible processes. This tensor shows then which slot from resource or queue is taken by which process type.</p> <p>The reward will be defined by a stepwise reward and a sparse reward:</p> <ul> <li>Stepwise reward: The agent receives a reward of -1 if he selects an invalid action, 1 if he selects a valid action which requires not setup and 0 otherwise.</li> <li>Sparse reward: The agent receives a reward based on the difference of queue capacity and WIP at the resource.</li> </ul> <p>Lastly, termination is defined by 100k minutes passed in simulation time and the info is just a placeholder.</p> <p>The following code shows the implementation of the environment:</p> <pre><code>class ProductionControlEnv(sequencing_control_env.AbstractSequencingControlEnv):\n    def get_observation(self) -&gt; np.ndarray:\n        \"\"\"\n        Function that utilizes the ResourceObserver of the environment class to get an array of observations of processes performed by the resource and in the queue of the resource. The observation has a dimension CxP, where C is the capacity of resource and queue and P the number of processes.\n\n        Returns:\n            np.ndarray: The observation.\n        \"\"\"\n        processes_observation = self.observer.observe_processes()\n        encoded_processes = []\n        processes = self.resource.data.process_ids\n\n        for process_observation in processes_observation:\n            encoded_process = [0 for _ in range(len(processes))]\n            encoded_process[processes.index(process_observation.process)] = 1\n            encoded_processes.append(encoded_process)\n\n        encoded_process = [0 for _ in range(len(processes))]\n        encoded_processes += [encoded_process] * (\n            self.resource.data.capacity - len(processes_observation)\n        )\n\n        queue_observations = self.observer.observe_input_queue()\n        for queue_observation in queue_observations:\n            encoded_process = [0 for _ in range(len(processes))]\n            encoded_process[processes.index(queue_observation.process)] = 1\n            encoded_processes.append(encoded_process)\n\n        encoded_process = [0 for _ in range(len(processes))]\n        queue_capacity = self.resource.input_queues[0].capacity\n        encoded_processes += [encoded_process] * (\n            queue_capacity - len(queue_observations)\n        )\n\n        return np.array(encoded_processes)\n\n    def get_info(self) -&gt; dict:\n        return {\"info\": 0}\n\n\n    def get_termination_condition(self) -&gt; bool:\n        return self.runner.env.now &gt;= 100000\n\n    def get_reward(self, processed_request: request.Request, invalid_action: bool = False) -&gt; float:\n        if invalid_action:\n            reward = -1\n        else:\n            reward = (\n                self.resource.current_setup is None\n                or processed_request.process.process_data.ID\n                == self.resource.current_setup.process_data.ID\n            )\n        if self.step_count % 10 == 0:\n            reward += self.resource.input_queues[0].capacity - len(self.resource_controller.requests) \n\n        return reward\n</code></pre> <p>Note that we utilize the observer, which is an attribute of the environment. The observer brings handy functions to observe the current state of a resource in the simulation.</p> <p>In order to validate that this environment works, we will at first use just random sampling as an agent and step through it. At first, we define the observation and action space since these are required by the environment and need to fit to our get_observation function:</p> <pre><code>resource_id = \"R2\"\nresource_data = [r for r in production_system.resource_data if r.ID == resource_id][0]\nqueue = [q for q in production_system.queue_data if q.ID == resource_data.input_queues[0]][0]\nshape = (queue.capacity + resource_data.capacity, len(resource_data.process_ids))\nobservation_space = spaces.Box(0, 1, shape=shape, dtype=int)\naction_space = spaces.Box(0, 1, shape=(queue.capacity,), dtype=float)\n</code></pre> <p>Now, we can create an instance of the environment and step through it:</p> <pre><code>env = ProductionControlEnv(production_system, \"R2\", observation_space=observation_space, action_space=action_space, render_mode=\"human\")\nobservation, info = env.reset(seed=42)\nfor step in range(20):\n   action = env.action_space.sample()  # this is where you would insert your policy\n   observation, reward, terminated, truncated, info = env.step(action)\n   print(f\"Step: {step} with a reward of {reward}\")\n\n   if terminated or truncated:\n      observation, info = env.reset()\nenv.close()\n</code></pre> <p>Lastly, we want to use a PPO RL-agent from stable-baselines3 to train the environment. We will use the default hyperparameters for the agent and train it for 20k steps. The following code shows the training:</p> <pre><code>import os\nimport time\nfrom stable_baselines3 import PPO\nfrom stable_baselines3.common.logger import configure\n\ntmp_path = os.getcwd() + \"\\\\tensorboard_log\\\\sequencing\\\\\" + time.strftime(\"%Y%m%d-%H%M%S\")\nnew_logger = configure(tmp_path, [\"stdout\", \"csv\", \"tensorboard\"])\n\nmodel = PPO(env=env, policy='MlpPolicy', verbose=1)\nmodel.set_logger(new_logger)\nmodel.learn(total_timesteps=20000)\n</code></pre> <p>You can review the training progress by looking at the tensorboard logs in the folder <code>tensorboard_log\\sequencing</code> in the current working directory. The following code will show the tensorboard logs in the notebook:</p> <pre><code>tensorboard --logdir tensorboard_log\\sequencing\n</code></pre> <p>This example should only show the required implementation for an RL-agent for production control tasks. The routing control task can be implemented in a similar fashion. For more information on the implementation of the environment, please refer to the documentation of the abstract base classes in the API reference of <code>prodsys.control</code>.</p>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/","title":"Advanced Dependencies","text":"<p>This tutorial explores advanced dependency modeling in <code>prodsys</code>. Dependencies allow you to model complex interactions between resources, processes, and products, such as assembly operations, worker requirements, tool dependencies, and lot-based processing.</p>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#overview-of-dependency-types","title":"Overview of Dependency Types","text":"<p><code>prodsys</code> supports several types of dependencies:</p> <ul> <li>ProcessDependency: A resource requires a specific process to be performed by another resource (e.g., assembly operations)</li> <li>ResourceDependency: A resource requires another resource to be available (e.g., a machine needs a worker)</li> <li>AssemblyDependency: A process requires specific products/components to be available (e.g., assembly needs screws and bolts)</li> <li>ToolDependency: A process requires a tool or auxiliary resource (e.g., workpiece carriers)</li> <li>LotDependency: A process requires products to be processed in batches/lots</li> </ul>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#processdependency","title":"ProcessDependency","text":"<p>A <code>ProcessDependency</code> models situations where a resource needs another resource to perform a specific process. For example, a machine might need a worker to perform an assembly operation.</p> <pre><code>import prodsys.express as psx\n\n# Create time models\nt1 = psx.FunctionTimeModel(\"normal\", 1, 0.1, \"t1\")\nt2 = psx.FunctionTimeModel(\"normal\", 2, 0.2, \"t2\")\n\n# Create processes\np1 = psx.ProductionProcess(t1, \"p1\")\np2 = psx.ProductionProcess(t2, \"p2\")\n\n# Create transport process\nt3 = psx.DistanceTimeModel(speed=180, reaction_time=0.1, ID=\"t3\")\ntp = psx.TransportProcess(t3, \"tp\")\nmove_p = psx.TransportProcess(t3, \"move\")\n\n# Create assembly process\nassembly_process = psx.ProductionProcess(\n    psx.FunctionTimeModel(\"exponential\", 0.1, ID=\"assembly_time\"), \n    \"assembly_process\"\n)\n\n# Create worker resource that can perform assembly\nworker = psx.ProductionResource(\n    processes=[move_p, assembly_process],\n    location=[2, 0],\n    capacity=1,\n    ID=\"worker\"\n)\n\n# Create interaction node where the dependency interaction occurs\ninteraction_node = psx.Node(location=[5, 6], ID=\"interaction_node_assembly\")\n\n# Create process dependency: machine requires assembly process from worker\nassembly_dependency = psx.ProcessDependency(\n    ID=\"assembly_dependency\",\n    required_process=assembly_process,\n    interaction_node=interaction_node,\n)\n\n# Create machine with the dependency\nmachine = psx.ProductionResource(\n    processes=[p1, p2],\n    location=[5, 5],\n    capacity=1,\n    dependencies=[assembly_dependency],\n    ID=\"machine\"\n)\n</code></pre>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#resourcedependency","title":"ResourceDependency","text":"<p>A <code>ResourceDependency</code> models situations where a resource requires another resource to be available. This is useful for modeling worker-machine interactions or resource sharing scenarios.</p> <pre><code># Create worker resource\nworker2 = psx.ProductionResource(\n    processes=[move_p, assembly_process],\n    location=[3, 0],\n    capacity=1,\n    ID=\"worker2\"\n)\n\n# Create interaction node\ninteraction_node_resource = psx.Node(location=[7, 4], ID=\"interaction_node_resource_2\")\n\n# Create resource dependency: machine2 requires worker2\nresource_2_dependency = psx.ResourceDependency(\n    ID=\"resource_2_dependency\",\n    required_resource=worker2,\n    interaction_node=interaction_node_resource,\n)\n\n# Create machine with resource dependency\nmachine2 = psx.ProductionResource(\n    processes=[p1, p2],\n    location=[7, 2],\n    capacity=3,\n    dependencies=[resource_2_dependency],\n    ID=\"machine2\"\n)\n</code></pre>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#assemblydependency","title":"AssemblyDependency","text":"<p>An <code>AssemblyDependency</code> models situations where a process requires specific products or components to be available. This is essential for modeling assembly operations.</p> <pre><code># Create time models for primitive components\nt_screw = psx.FunctionTimeModel(\"normal\", 2, 0.2, \"t_screw\")\nt_bolt = psx.FunctionTimeModel(\"normal\", 3, 0.3, \"t_bolt\")\nt_washer = psx.FunctionTimeModel(\"normal\", 1, 0.1, \"t_washer\")\n\n# Create processes for primitives\np_screw = psx.ProductionProcess(t_screw, \"p_screw\")\np_bolt = psx.ProductionProcess(t_bolt, \"p_bolt\")\np_washer = psx.ProductionProcess(t_washer, \"p_washer\")\n\n# Create transport process\nt_transport = psx.DistanceTimeModel(speed=100, reaction_time=0.1, ID=\"t_transport\")\ntp = psx.TransportProcess(t_transport, \"tp\")\n\n# Create primitive products\nscrew = psx.Product(process=[p_screw], transport_process=tp, ID=\"screw\")\nbolt = psx.Product(process=[p_bolt], transport_process=tp, ID=\"bolt\")\nwasher = psx.Product(process=[p_washer], transport_process=tp, ID=\"washer\")\n\n# Create assembly dependencies\nscrew_dependency = psx.AssemblyDependency(required_entity=screw)\nbolt_dependency = psx.AssemblyDependency(required_entity=bolt)\n\n# Create subassembly process with dependencies\nt_subassembly = psx.FunctionTimeModel(\"normal\", 5, 0.5, \"t_subassembly\")\np_subassembly = psx.ProductionProcess(\n    t_subassembly, \n    \"p_subassembly\",\n    dependencies=[screw_dependency, bolt_dependency]\n)\n\n# Create subassembly product\nsubassembly = psx.Product(\n    process=[p_subassembly], \n    transport_process=tp, \n    ID=\"subassembly\"\n)\n\n# Create main assembly with subassembly and washer dependencies\nsubassembly_dependency = psx.AssemblyDependency(required_entity=subassembly)\nwasher_dependency = psx.AssemblyDependency(required_entity=washer)\n\nt_main_assembly = psx.FunctionTimeModel(\"normal\", 10, 1.0, \"t_main_assembly\")\np_main_assembly = psx.ProductionProcess(\n    t_main_assembly,\n    \"p_main_assembly\",\n    dependencies=[subassembly_dependency, washer_dependency]\n)\n\n# Create main assembly product\nmain_assembly = psx.Product(\n    process=[p_main_assembly], \n    transport_process=tp, \n    ID=\"main_assembly\"\n)\n</code></pre>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#tooldependency","title":"ToolDependency","text":"<p>A <code>ToolDependency</code> models situations where a process requires a tool or auxiliary resource, such as workpiece carriers, fixtures, or other supporting equipment.</p> <pre><code># Create transport process for workpiece carrier\nt3 = psx.DistanceTimeModel(60, 0.05, \"manhattan\", ID=\"t3\")\ntp = psx.TransportProcess(t3, \"tp\")\n\n# Create storage for workpiece carriers\nstorage1 = psx.Store(ID=\"storage1\", location=[6, 0], capacity=30)\nstorage2 = psx.Store(ID=\"storage2\", location=[11, 0], capacity=20)\n\n# Create workpiece carrier primitive\nworkpiece_carrier = psx.Primitive(\n    ID=\"workpiece_carrier\",\n    transport_process=tp,\n    storages=[storage1, storage2],\n    quantity_in_storages=[5, 20],\n)\n\n# Create tool dependency\nworkpiece_carrier_dependency = psx.ToolDependency(\n    ID=\"workpiece_carrier_dependency\",\n    required_entity=workpiece_carrier,\n)\n\n# Create product with tool dependency\nproduct1 = psx.Product(\n    process=[p1],\n    transport_process=tp,\n    ID=\"product1\",\n    dependencies=[workpiece_carrier_dependency],\n)\n</code></pre>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#lotdependency","title":"LotDependency","text":"<p>A <code>LotDependency</code> models situations where products must be processed in batches or lots. This is useful for modeling batch processing, where multiple products are processed together.</p> <pre><code># Create lot dependency for batch processing\nlot_dependency = psx.LotDependency(\n    min_lot_size=2,\n    max_lot_size=4,\n    ID=\"lot_dependency\",\n)\n\n# Create machine with lot dependency\nmachine = psx.ProductionResource(\n    processes=[p1],\n    location=[5, 0],\n    capacity=5,\n    ID=\"machine\",\n    dependencies=[lot_dependency],\n)\n\n# Alternatively, lot dependency can be added to transport process\ntp_with_lot = psx.TransportProcess(\n    t3, \n    \"tp\", \n    dependencies=[lot_dependency]\n)\n</code></pre>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#complete-example-assembly-with-worker-dependency","title":"Complete Example: Assembly with Worker Dependency","text":"<p>Here's a complete example combining multiple dependency types:</p> <pre><code>import prodsys.express as psx\nfrom prodsys import runner\n\n# Time models\nt_screw = psx.FunctionTimeModel(\"normal\", 2, 0.2, \"t_screw\")\nt_bolt = psx.FunctionTimeModel(\"normal\", 3, 0.3, \"t_bolt\")\nt_washer = psx.FunctionTimeModel(\"normal\", 1, 0.1, \"t_washer\")\nt_transport = psx.DistanceTimeModel(speed=100, reaction_time=0.1, ID=\"t_transport\")\n\n# Processes\np_screw = psx.ProductionProcess(t_screw, \"p_screw\")\np_bolt = psx.ProductionProcess(t_bolt, \"p_bolt\")\np_washer = psx.ProductionProcess(t_washer, \"p_washer\")\ntp = psx.TransportProcess(t_transport, \"tp\")\n\n# Primitive products\nscrew = psx.Product(process=[p_screw], transport_process=tp, ID=\"screw\")\nbolt = psx.Product(process=[p_bolt], transport_process=tp, ID=\"bolt\")\nwasher = psx.Product(process=[p_washer], transport_process=tp, ID=\"washer\")\n\n# Assembly dependencies\nscrew_dependency = psx.AssemblyDependency(required_entity=screw)\nbolt_dependency = psx.AssemblyDependency(required_entity=bolt)\n\n# Subassembly process\nt_subassembly = psx.FunctionTimeModel(\"normal\", 5, 0.5, \"t_subassembly\")\np_subassembly = psx.ProductionProcess(\n    t_subassembly, \n    \"p_subassembly\",\n    dependencies=[screw_dependency, bolt_dependency]\n)\nsubassembly = psx.Product(process=[p_subassembly], transport_process=tp, ID=\"subassembly\")\n\n# Main assembly dependencies\nsubassembly_dependency = psx.AssemblyDependency(required_entity=subassembly)\nwasher_dependency = psx.AssemblyDependency(required_entity=washer)\n\n# Main assembly process\nt_main_assembly = psx.FunctionTimeModel(\"normal\", 10, 1.0, \"t_main_assembly\")\np_main_assembly = psx.ProductionProcess(\n    t_main_assembly,\n    \"p_main_assembly\",\n    dependencies=[subassembly_dependency, washer_dependency]\n)\nmain_assembly = psx.Product(process=[p_main_assembly], transport_process=tp, ID=\"main_assembly\")\n\n# Worker resource\nworker_process = psx.ProductionProcess(\n    psx.FunctionTimeModel(\"exponential\", 0.5, ID=\"worker_process_time\"),\n    \"worker_process\"\n)\nworker_transport = psx.TransportProcess(t_transport, \"worker_transport\")\nfrom prodsys.models.resource_data import TransportControlPolicy\nworker = psx.ProductionResource(\n    processes=[worker_transport, worker_process, tp],\n    location=[1, 1],\n    capacity=1,\n    control_policy=TransportControlPolicy.SPT_transport,\n    ID=\"worker\",\n)\n\n# Resource dependency: assembly station requires worker\ninteraction_node = psx.Node(location=[5, 5], ID=\"interaction_node\")\nworker_dependency = psx.ResourceDependency(\n    ID=\"worker_dependency\",\n    required_resource=worker,\n    interaction_node=interaction_node,\n)\n\n# Assembly station with worker dependency\nassembly_station = psx.ProductionResource(\n    processes=[p_subassembly, p_main_assembly, p_screw, p_bolt, p_washer],\n    location=[5, 5],\n    capacity=1,\n    ID=\"assembly_station\",\n    dependencies=[worker_dependency],\n)\n\n# Create sources, sinks, and production system\narrival_model = psx.FunctionTimeModel(\"exponential\", 30, ID=\"arrival_model\")\nsource_screw = psx.Source(screw, arrival_model, [0, 0], ID=\"source_screw\")\nsource_bolt = psx.Source(bolt, arrival_model, [0, 0], ID=\"source_bolt\")\nsource_washer = psx.Source(washer, arrival_model, [0, 0], ID=\"source_washer\")\n\nsink_main_assembly = psx.Sink(main_assembly, [10, 5], \"sink_main_assembly\")\n\nsystem = psx.ProductionSystem(\n    resources=[assembly_station, worker],\n    sources=[source_screw, source_bolt, source_washer],\n    sinks=[sink_main_assembly],\n)\n\n# Run simulation\nmodel = system.to_model()\nrunner_instance = runner.Runner(production_system_data=model)\nrunner_instance.initialize_simulation()\nrunner_instance.run(1000)\nrunner_instance.print_results()\n</code></pre>"},{"location":"Tutorials/tutorial_5_advanced_dependencies/#key-points","title":"Key Points","text":"<ol> <li> <p>Dependencies create constraints: They ensure that required resources, processes, or products are available before a process can start.</p> </li> <li> <p>Interaction nodes: For <code>ProcessDependency</code> and <code>ResourceDependency</code>, you must specify an <code>interaction_node</code> where the dependency interaction occurs.</p> </li> <li> <p>Assembly dependencies: Use <code>AssemblyDependency</code> to model bill-of-materials relationships where products require components.</p> </li> <li> <p>Tool dependencies: Use <code>ToolDependency</code> for auxiliary resources like workpiece carriers, fixtures, or tools.</p> </li> <li> <p>Lot dependencies: Use <code>LotDependency</code> to model batch processing where multiple products are processed together.</p> </li> </ol> <p>For more information about dependencies and their usage, please see the API reference or check out the examples in the modelling and simulation examples folder.</p>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/","title":"Orders and Schedules","text":"<p>This tutorial explores order-based production and schedule-based production control in <code>prodsys</code>. These features allow you to model production systems where products are released based on customer orders or predefined schedules.</p>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#order-based-production","title":"Order-Based Production","text":"<p>Order-based production allows you to model production systems where products are created based on customer orders rather than continuous arrival processes. This is useful for make-to-order scenarios.</p>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#creating-orders","title":"Creating Orders","text":"<p>An <code>Order</code> specifies what products should be produced, in what quantities, and when they should be released into the production system.</p> <pre><code>import prodsys.express as psx\n\n# Create time models and processes\nt1 = psx.FunctionTimeModel(\"normal\", 1, 0.1, \"t1\")\nt2 = psx.FunctionTimeModel(\"normal\", 2, 0.2, \"t2\")\np1 = psx.ProductionProcess(t1, \"p1\")\np2 = psx.ProductionProcess(t2, \"p2\")\n\nt3 = psx.DistanceTimeModel(speed=180, reaction_time=0.1, ID=\"t3\")\ntp = psx.TransportProcess(t3, \"tp\")\n\n# Create products\nproduct1 = psx.Product(process=[p1, p2], transport_process=tp, ID=\"product1\")\nproduct2 = psx.Product(process=[p2, p1], transport_process=tp, ID=\"product2\")\n\n# Create an order with a single product type\norder1 = psx.Order(\n    ID=\"order1\",\n    ordered_products=[psx.OrderedProduct(product=product1, quantity=2)],\n    order_time=0.0,      # When the order was placed\n    release_time=10.0,   # When products should be released into the system\n    priority=1,\n)\n\n# Create an order with multiple product types\norder2 = psx.Order(\n    ID=\"order2\",\n    ordered_products=[\n        psx.OrderedProduct(product=product1, quantity=1),\n        psx.OrderedProduct(product=product2, quantity=1),\n    ],\n    order_time=5.0,\n    release_time=20.0,\n    priority=1,\n)\n</code></pre>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#using-ordersource","title":"Using OrderSource","text":"<p>An <code>OrderSource</code> creates products based on orders rather than a continuous arrival process. Products are released at the times specified in the orders.</p> <pre><code># Create order source with multiple orders\norder_source = psx.OrderSource(\n    orders=[order1, order2],\n    location=[0, 0],\n    ID=\"order_source\",\n)\n\n# Create resources\nmachine = psx.ProductionResource(\n    processes=[p1, p2],\n    location=[5, 0],\n    capacity=2,\n    ID=\"machine\",\n)\ntransport = psx.TransportResource(\n    processes=[tp],\n    location=[2, 0],\n    capacity=1,\n    ID=\"transport\",\n)\n\n# Create sinks\nsink1 = psx.Sink(product1, [10, 0], \"sink1\")\nsink2 = psx.Sink(product2, [10, 0], \"sink2\")\n\n# Create production system with order source\nsystem = psx.ProductionSystem(\n    resources=[machine, transport],\n    sources=[order_source],\n    sinks=[sink1, sink2]\n)\n</code></pre>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#combining-orders-with-conwip","title":"Combining Orders with ConWIP","text":"<p>You can combine order-based production with ConWIP (Constant Work in Progress) control to limit the number of products in the system:</p> <pre><code># Convert to model and set ConWIP limit\nmodel = system.to_model()\nmodel.conwip_number = 5  # Maximum 5 products in the system\n\n# Run simulation\nfrom prodsys.simulation import runner\nrunner_instance = runner.Runner(production_system_data=model)\nrunner_instance.initialize_simulation()\nsystem.run(100)\nsystem.runner.print_results()\n</code></pre>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#schedule-based-production","title":"Schedule-Based Production","text":"<p>Schedule-based production allows you to define exactly when specific products should be released and which resources should process them. This is useful for production planning and scheduling scenarios.</p>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#creating-a-schedule","title":"Creating a Schedule","text":"<p>A schedule is a list of schedule events that specify: - Time: When the event should occur - Product: Which product should be created/processed - Resource: Which resource should process the product - Process: Which process should be performed</p> <pre><code>from prodsys.models import production_system_data\n\n# Load a configuration with schedule\nconfig = production_system_data.ProductionSystemData.read(\n    \"examples/modelling_and_simulation/simulation_example_data/schedule_example.json\"\n)\n\n# The schedule is defined in the configuration file\n# Each schedule event specifies:\n# - time: When the event occurs\n# - product: Product ID to create\n# - resource: Resource ID that should process it\n# - process: Process ID to perform\n\nprint(f\"Number of scheduled events: {len(config.schedule) if config.schedule else 0}\")\n</code></pre>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#schedule-structure","title":"Schedule Structure","text":"<p>A schedule event typically looks like this:</p> <pre><code>{\n    \"time\": 10.5,\n    \"product\": \"Product_A_1\",\n    \"resource\": \"R1\",\n    \"process\": \"P1\"\n}\n</code></pre> <p>This means: \"At time 10.5, create Product_A_1 and route it to resource R1 to perform process P1.\"</p>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#running-schedule-based-simulation","title":"Running Schedule-Based Simulation","text":"<pre><code>from prodsys.simulation import runner\n\n# Create and run the simulation\nsim_runner = runner.Runner(production_system_data=config)\nsim_runner.initialize_simulation()\n\n# Calculate simulation time based on schedule\nif config.schedule:\n    max_schedule_time = max(event.time for event in config.schedule)\n    simulation_time = max_schedule_time + 100  # Add buffer for processing\nelse:\n    simulation_time = 2000\n\nsim_runner.run(simulation_time)\n\n# Analyze results\nperformance = sim_runner.get_performance_data()\nprint(f\"Number of events in event log: {len(performance.event_log)}\")\n</code></pre>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#validating-schedule-adherence","title":"Validating Schedule Adherence","text":"<p>You can validate that the simulation followed the schedule:</p> <pre><code># Get scheduled production starts\nscheduled_releases = [\n    e for e in performance.event_log \n    if e.activity == \"start state\" and e.state_type == \"Production\"\n]\n\n# Validate routing\nfor scheduled_event in config.schedule:\n    actual_events = [\n        e for e in scheduled_releases \n        if e.product == scheduled_event.product\n        and hasattr(e, 'state') and e.state == scheduled_event.process\n    ]\n\n    if actual_events:\n        actual_event = actual_events[0]\n        scheduled_time = scheduled_event.time\n        actual_time = actual_event.time\n        delay = actual_time - scheduled_time\n\n        print(f\"Product {scheduled_event.product}: \"\n              f\"Scheduled={scheduled_time:.2f}, \"\n              f\"Actual={actual_time:.2f}, \"\n              f\"Delay={delay:.2f}\")\n</code></pre>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#complete-example-order-based-production","title":"Complete Example: Order-Based Production","text":"<p>Here's a complete example of order-based production:</p> <pre><code>import prodsys.express as psx\nimport prodsys\n\n# Create time models\nt1 = psx.FunctionTimeModel(\"normal\", 1, 0.1, \"t1\")\nt2 = psx.FunctionTimeModel(\"normal\", 2, 0.2, \"t2\")\n\n# Create processes\np1 = psx.ProductionProcess(t1, \"p1\")\np2 = psx.ProductionProcess(t2, \"p2\")\n\nt3 = psx.DistanceTimeModel(speed=180, reaction_time=0.1, ID=\"t3\")\ntp = psx.TransportProcess(t3, \"tp\")\n\n# Create setup states\ns1 = psx.FunctionTimeModel(\"exponential\", 0.5, ID=\"s1\")\nsetup_state_1 = psx.SetupState(s1, p1, p2, \"S1\")\nsetup_state_2 = psx.SetupState(s1, p2, p1, \"S2\")\n\n# Create resources\nmachine = psx.ProductionResource(\n    processes=[p1, p2],\n    location=[5, 0],\n    capacity=2,\n    states=[setup_state_1, setup_state_2],\n    ID=\"machine\",\n)\nmachine2 = psx.ProductionResource(\n    processes=[p1, p2],\n    location=[7, 0],\n    capacity=2,\n    states=[setup_state_1, setup_state_2],\n    ID=\"machine2\",\n)\ntransport = psx.TransportResource(\n    processes=[tp],\n    location=[2, 0],\n    capacity=1,\n    ID=\"transport\",\n)\n\n# Create products\nproduct1 = psx.Product(process=[p1, p2], transport_process=tp, ID=\"product1\")\nproduct2 = psx.Product(process=[p2, p1], transport_process=tp, ID=\"product2\")\n\n# Create sinks\nsink1 = psx.Sink(product1, [10, 0], \"sink1\")\nsink2 = psx.Sink(product2, [10, 0], \"sink2\")\n\n# Create orders with different release times\norder1 = psx.Order(\n    ID=\"order1\",\n    ordered_products=[psx.OrderedProduct(product=product1, quantity=2)],\n    order_time=0.0,\n    release_time=10.0,\n    priority=1,\n)\n\norder2 = psx.Order(\n    ID=\"order2\",\n    ordered_products=[psx.OrderedProduct(product=product2, quantity=1)],\n    order_time=5.0,\n    release_time=15.0,\n    priority=1,\n)\n\n# Order with multiple product types\norder3 = psx.Order(\n    ID=\"order3\",\n    ordered_products=[\n        psx.OrderedProduct(product=product1, quantity=1),\n        psx.OrderedProduct(product=product2, quantity=1),\n    ],\n    order_time=10.0,\n    release_time=20.0,\n    priority=1,\n)\n\n# Create order source\norder_source = psx.OrderSource(\n    orders=[order1, order2, order3],\n    location=[0, 0],\n    ID=\"order_source\",\n)\n\n# Create production system\nsystem = psx.ProductionSystem(\n    resources=[machine, machine2, transport],\n    sources=[order_source],\n    sinks=[sink1, sink2]\n)\n\n# Set ConWip limit\nmodel = system.to_model()\nmodel.conwip_number = 5\n\n# Run simulation\nfrom prodsys.simulation import runner\nrunner_instance = runner.Runner(production_system_data=model)\nrunner_instance.initialize_simulation()\nsystem.run(100)\nsystem.runner.print_results()\n</code></pre>"},{"location":"Tutorials/tutorial_6_orders_and_schedules/#key-points","title":"Key Points","text":"<ol> <li> <p>Order-based production: Use <code>OrderSource</code> with <code>Order</code> objects to model make-to-order scenarios where products are created based on customer orders.</p> </li> <li> <p>Schedule-based production: Use schedules to define exactly when and where products should be processed, useful for production planning and scheduling.</p> </li> <li> <p>Order properties:</p> </li> <li><code>order_time</code>: When the order was placed</li> <li><code>release_time</code>: When products should be released into the system</li> <li><code>priority</code>: Order priority (higher values = higher priority)</li> <li> <p><code>ordered_products</code>: List of products and quantities</p> </li> <li> <p>ConWIP control: Combine orders with ConWIP to limit work in progress.</p> </li> <li> <p>Schedule validation: You can validate that the simulation followed the schedule by comparing scheduled events with actual events in the event log.</p> </li> </ol> <p>For more information about orders and schedules, please see the API reference or check out the examples in the modelling and simulation examples folder.</p>"},{"location":"Tutorials/tutorial_7_system_resources/","title":"System Resources","text":"<p>This tutorial explores <code>SystemResource</code>, a powerful feature in <code>prodsys</code> that allows you to model hierarchical production systems where a resource contains other resources as subresources. This is useful for modeling manufacturing cells, production lines, or complex workstations.</p>"},{"location":"Tutorials/tutorial_7_system_resources/#overview","title":"Overview","text":"<p>A <code>SystemResource</code> represents a resource that contains other resources (subresources) and can perform processes that are distributed across its subresources. This allows you to:</p> <ul> <li>Model manufacturing cells with multiple machines</li> <li>Create hierarchical production systems</li> <li>Group related resources together</li> <li>Model complex workstations with internal routing</li> </ul>"},{"location":"Tutorials/tutorial_7_system_resources/#basic-systemresource","title":"Basic SystemResource","text":"<p>A basic <code>SystemResource</code> contains a list of subresource IDs and can perform processes that are executed by its subresources.</p> <pre><code>import prodsys.express as psx\n\n# Create time models\ntm_machine1 = psx.FunctionTimeModel(\"normal\", 1.8, 0.2, \"tm_machine1\")\ntm_machine2 = psx.FunctionTimeModel(\"normal\", 2.2, 0.7, \"tm_machine2\")\ntm_transport = psx.DistanceTimeModel(speed=60, reaction_time=0.1, metric=\"manhattan\", ID=\"tm_transport\")\ntm_arrival = psx.FunctionTimeModel(\"exponential\", 2.5, ID=\"tm_arrival\")\n\n# Create processes\nmachine1_process = psx.ProductionProcess(time_model=tm_machine1, ID=\"machine1_process\")\nmachine2_process = psx.ProductionProcess(time_model=tm_machine2, ID=\"machine2_process\")\ntransport_process = psx.TransportProcess(time_model=tm_transport, ID=\"transport_process\")\n\n# Create individual machine resources\nmachine1 = psx.ProductionResource(\n    processes=[machine1_process],\n    location=[12, 8],\n    capacity=1,\n    ID=\"machine1\"\n)\n\nmachine2 = psx.ProductionResource(\n    processes=[machine2_process],\n    location=[12, 12],\n    capacity=1,\n    ID=\"machine2\"\n)\n\n# Create a ProcessModel for the cell\n# This defines how processes are executed within the system resource\ncell_process_model = psx.ProcessModel(\n    adjacency_matrix={\n        \"machine1_process\": [\"machine2_process\"],\n        \"machine2_process\": []\n    },\n    ID=\"cell_process_model\"\n)\n\n# Create SystemResource (manufacturing cell)\nmanufacturing_cell = psx.SystemResource(\n    processes=[cell_process_model],\n    location=[10, 10],\n    subresource_ids=[\"machine1\", \"machine2\"],\n    capacity=5,  # Capacity of the system resource\n    ID=\"manufacturing_cell\"\n)\n</code></pre>"},{"location":"Tutorials/tutorial_7_system_resources/#systemresource-with-processmodel","title":"SystemResource with ProcessModel","text":"<p>A <code>SystemResource</code> typically uses a <code>ProcessModel</code> to define how processes are executed across its subresources. The <code>ProcessModel</code> can represent sequential, parallel, or complex workflows.</p> <pre><code># Create a ProcessModel with parallel execution\n# Workflow: machine1_process OR machine2_process (parallel choice)\ncell_process_model = psx.ProcessModel(\n    adjacency_matrix={\n        \"machine1_process\": [],\n        \"machine2_process\": []\n    },\n    ID=\"cell_process_model\"\n)\n\n# Create SystemResource with the process model\nmanufacturing_cell = psx.SystemResource(\n    processes=[cell_process_model],\n    location=[10, 10],\n    subresource_ids=[\"machine1\", \"machine2\"],\n    capacity=5,\n    ID=\"manufacturing_cell\"\n)\n</code></pre>"},{"location":"Tutorials/tutorial_7_system_resources/#nested-systemresources","title":"Nested SystemResources","text":"<p>You can create nested <code>SystemResource</code> objects where a system resource contains other system resources:</p> <pre><code># Create a ProcessModel for the outer system resource\nproduct_process_model = psx.ProcessModel(\n    can_contain_other_models=True,\n    ID=\"product_process_model\",\n    adjacency_matrix={\n        \"machine3_process\": [\"cell_process_model\"],\n        \"cell_process_model\": []\n    }\n)\n\n# Create outer system resource that contains the manufacturing cell\nouter_system = psx.SystemResource(\n    processes=[product_process_model],\n    location=[15, 10],\n    subresource_ids=[\"machine3\", \"manufacturing_cell\"],\n    capacity=10,\n    ID=\"outer_system\"\n)\n</code></pre>"},{"location":"Tutorials/tutorial_7_system_resources/#systemresource-with-robot","title":"SystemResource with Robot","text":"<p>A common use case is a manufacturing cell with a robot that loads and unloads products:</p> <pre><code># Create robot time model\ntm_robot_handling = psx.FunctionTimeModel(\n    distribution_function=\"normal\",\n    location=5.0,\n    scale=1.0,\n    ID=\"tm_robot_handling\"\n)\n\n# Create robot process\nrobot_handling_process = psx.TransportProcess(\n    time_model=tm_robot_handling,\n    ID=\"robot_handling\"\n)\n\n# Create robot resource\nrobot = psx.ProductionResource(\n    processes=[transport_process],  # Robot can also transport\n    location=[12, 10],\n    capacity=1,\n    ID=\"robot\"\n)\n\n# Create ProcessModel for the cell\n# Workflow: robot loads \u2192 (machine1 OR machine2) \u2192 robot unloads\ncell_process_model = psx.ProcessModel(\n    adjacency_matrix={\n        \"machine1_process\": [],\n        \"machine2_process\": []\n    },\n    ID=\"cell_process_model\"\n)\n\n# Create SystemResource with robot and machines\nmanufacturing_cell = psx.SystemResource(\n    processes=[cell_process_model],\n    location=[10, 10],\n    subresource_ids=[\"robot\", \"machine1\", \"machine2\"],\n    capacity=5,\n    ID=\"manufacturing_cell\"\n)\n</code></pre>"},{"location":"Tutorials/tutorial_7_system_resources/#complete-example-manufacturing-cell","title":"Complete Example: Manufacturing Cell","text":"<p>Here's a complete example of a manufacturing cell with a robot and multiple machines:</p> <pre><code>import prodsys.express as psx\n\ndef main():\n    \"\"\"Main example function.\"\"\"\n\n    # ========== TIME MODELS ==========\n    # Robot time models\n    tm_robot_handling = psx.FunctionTimeModel(\n        distribution_function=\"normal\",\n        location=5.0,\n        scale=1.0,\n        ID=\"tm_robot_handling\"\n    )\n\n    # Machine time models\n    tm_machine1 = psx.FunctionTimeModel(\n        distribution_function=\"normal\",\n        location=1.8,\n        scale=0.2,\n        ID=\"tm_machine1\"\n    )\n    tm_machine2 = psx.FunctionTimeModel(\n        distribution_function=\"normal\",\n        location=2.2,\n        scale=0.7,\n        ID=\"tm_machine2\"\n    )\n\n    # Transport and arrival time models\n    tm_agv = psx.DistanceTimeModel(\n        speed=60.0,\n        reaction_time=0.1,\n        metric=\"manhattan\",\n        ID=\"tm_agv\"\n    )\n    tm_arrival = psx.FunctionTimeModel(\n        distribution_function=\"exponential\",\n        location=2.5,\n        ID=\"tm_arrival\"\n    )\n\n    # ========== PROCESSES ==========\n    # Machine processes\n    machine1_process = psx.ProductionProcess(\n        time_model=tm_machine1,\n        ID=\"machine1_process\"\n    )\n    machine2_process = psx.ProductionProcess(\n        time_model=tm_machine2,\n        ID=\"machine2_process\"\n    )\n\n    # Transport process\n    agv_transport = psx.TransportProcess(\n        time_model=tm_agv,\n        ID=\"agv_transport\"\n    )\n\n    # ========== PROCESS MODEL ==========\n    # Create ProcessModel with parallel execution\n    # Workflow: (machine1_process OR machine2_process)\n    cell_process_model = psx.ProcessModel(\n        adjacency_matrix={\n            \"machine1_process\": [],\n            \"machine2_process\": []\n        },\n        ID=\"cell_process_model\"\n    )\n\n    # Product process model that includes the cell\n    product_process_model = psx.ProcessModel(\n        can_contain_other_models=True,\n        ID=\"product_process_model\",\n        adjacency_matrix={\n            \"cell_process_model\": []\n        }\n    )\n\n    # ========== RESOURCES ==========\n    # Robot resource\n    robot = psx.ProductionResource(\n        processes=[agv_transport],\n        location=[12, 10],\n        capacity=1,\n        ID=\"robot\"\n    )\n\n    # Machine resources\n    machine1 = psx.ProductionResource(\n        processes=[machine1_process],\n        location=[12, 8],\n        capacity=1,\n        ID=\"machine1\"\n    )\n    machine2 = psx.ProductionResource(\n        processes=[machine2_process],\n        location=[12, 12],\n        capacity=1,\n        ID=\"machine2\"\n    )\n\n    # AGV for global transport\n    agv = psx.TransportResource(\n        processes=[agv_transport],\n        location=[0, 10],\n        capacity=1,\n        ID=\"agv\"\n    )\n\n    # ========== SYSTEM RESOURCE (CELL) ==========\n    manufacturing_cell = psx.SystemResource(\n        processes=[cell_process_model],\n        location=[10, 10],\n        subresource_ids=[\"robot\", \"machine1\", \"machine2\"],\n        capacity=5,\n        ID=\"manufacturing_cell\"\n    )\n\n    # ========== PRODUCT ==========\n    product = psx.Product(\n        process=product_process_model,\n        transport_process=agv_transport,\n        ID=\"product\"\n    )\n\n    # ========== SOURCES AND SINKS ==========\n    source = psx.Source(product, tm_arrival, [0, 10], ID=\"source\")\n    sink = psx.Sink(product, [20, 10], ID=\"sink\")\n\n    # ========== PRODUCTION SYSTEM ==========\n    system = psx.ProductionSystem(\n        resources=[robot, machine1, machine2, manufacturing_cell, agv],\n        sources=[source],\n        sinks=[sink],\n        ID=\"production_system\"\n    )\n\n    # ========== VALIDATION AND SIMULATION ==========\n    system.validate()\n    system.run(1000)\n    system.runner.print_results()\n</code></pre>"},{"location":"Tutorials/tutorial_7_system_resources/#key-points","title":"Key Points","text":"<ol> <li> <p>Subresources: A <code>SystemResource</code> contains other resources (subresources) identified by their IDs.</p> </li> <li> <p>ProcessModel: A <code>SystemResource</code> typically uses a <code>ProcessModel</code> to define how processes are executed across its subresources.</p> </li> <li> <p>Capacity: The <code>SystemResource</code> has its own capacity, which limits how many products can be in the system resource at once.</p> </li> <li> <p>Hierarchical modeling: You can create nested <code>SystemResource</code> objects for complex hierarchical production systems.</p> </li> <li> <p>Internal routing: The <code>ProcessModel</code> defines how products are routed between subresources within the system resource.</p> </li> <li> <p>Location: The <code>SystemResource</code> has a location, but subresources can have their own locations relative to the system resource.</p> </li> </ol>"},{"location":"Tutorials/tutorial_7_system_resources/#use-cases","title":"Use Cases","text":"<ul> <li>Manufacturing cells: Model cells with multiple machines and a robot</li> <li>Production lines: Group related resources together</li> <li>Workstations: Model complex workstations with internal processes</li> <li>Hierarchical systems: Create multi-level production systems</li> </ul> <p>For more information about system resources, please see the API reference or check out the examples in the modelling and simulation examples folder.</p>"}]}