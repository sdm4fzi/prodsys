{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>prodsys - modeling, simulating and optimizing production systems</p> <p> </p> <p>prodsys is a python package for modeling, simulating and optimizing production systems based on the product, process and resource (PPR) modelling principle. </p>"},{"location":"#installation","title":"Installation","text":"<p>To install the package, run the following command in the terminal:</p> <pre><code>pip install prodsys\n</code></pre> <p>Please note that prodsys is currently only fully compatible with Python 3.11. Other versions might cause some errors.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>The package is designed to be easy to use. The following example shows how to model a simple production system and simulate it. The production system contains a single milling machine that performs milling processes on aluminium housings. The transport is thereby performed by a worker.  At first, just import the express API of <code>prodsys</code>:</p> <pre><code>import prodsys.express as psx\n</code></pre> <p>We now create all components required for describing the production system. At first we define times for all arrival, production and transport processes:</p> <pre><code>milling_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=1, scale=0.1, ID=\"milling_time\")\ntransport_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=0.3, scale=0.2, ID=\"transport_time\")\narrival_time_of_housings = psx.FunctionTimeModel(distribution_function=\"exponential\", location=1.5, ID=\"arrival_time_of_housings\")\n</code></pre> <p>Next, we can define the production and transport process in the system by using the created time models:</p> <pre><code>milling_process = psx.ProductionProcess(milling_time, ID=\"milling_process\")\ntransport_process = psx.TransportProcess(transport_time, ID=\"transport_process\")\n</code></pre> <p>With the processes defined, we can now create the production and transport resources:</p> <pre><code>milling_machine = psx.ProductionResource([milling_process], location=[5, 5], ID=\"milling_machine\")\nworker = psx.TransportResource([transport_process], location=[0, 0], ID=\"worker\")\n</code></pre> <p>Now we define our product, the housing, that is produced in the system. For this example it requires only a single processsing step:</p> <pre><code>housing = psx.Product([milling_process], transport_process, ID=\"housing\")\n</code></pre> <p>Only the sources and sinks that are responsible for creating the housing and storing finished housing are misssing:</p> <pre><code>source = psx.Source(housing, arrival_time_of_housings, location=[0, 0], ID=\"source\")\nsink = psx.Sink(housing, location=[20, 20], ID=\"sink\")\n</code></pre> <p>Finally, we can create our production system, run the simulation for 60 minutes and print aggregated simulation results:</p> <pre><code>production_system = psx.ProductionSystem([milling_machine, worker], [source], [sink])\nproduction_system.run(60)\nproduction_system.runner.print_results()\n</code></pre> <p>As we can see, the system produced 39 parts in this hour with an work in progress (WIP ~ number of products in the system) of 4.125 and utilized the milling machine with 79.69% and the worker for 78.57% at the PR percentage, the rest of the time, both resource are in standby (SB). Note that these results stay the same although there are stochastic processes in the simulation. This is caused by seeding the random number generator with a fixed value. If you want to get different results, just specify another value for <code>seed</code> parameter from the <code>run</code> method.</p> <pre><code>production_system.run(60, seed=1)\nproduction_system.runner.print_results()\n</code></pre> <p>As expected, the performance of the production system changed quite strongly with the new parameters. The system now produces 26 parts in this hour with an work in progress (WIP ~ number of products in the system) of 1.68. As the arrival process of the housing is modelled by an exponential distribution and we only consider 60 minutes of simulation, this is absolutely expected.</p> <p>However, running longer simulations with multiple seeds is absolutely easy with <code>prodsys</code>. We average our results at the end to calculate the WIP to expect by utilizing the post_processor of the runner, which stores all events of a simulation and has many useful methods for analyzing the simulation results:</p> <pre><code>wip_values = []\n\nfor seed in range(5):\n    production_system.run(2000, seed=seed)\n    run_wip = production_system.post_processor.get_aggregated_wip_data()\n    wip_values.append(run_wip)\n\nprint(\"WIP values for the simulation runs:\", wip_values)\n</code></pre> <p>We can analyze these results easily with numpy seeing that the average WIP is 2.835, which is in between the two first runs, which gives us a more realistic expectation of the system's performance.</p> <pre><code>import numpy as np\nwip = np.array(wip_values).mean(axis=0)\nprint(wip)\n</code></pre> <p>These examples only cover the most basic functionalities of <code>prodsys</code>. For more elaborate guides that guide you through more of the package's features, please see the tutorials. For a complete overview of the package's functionality, please see the API reference.</p>"},{"location":"#run-prodsys-as-a-webserver-with-rest-api","title":"Run prodsys as a webserver with REST API","text":"<p>prodsys cannot only be used as a python package, but can also be used as a webserver by interacting with its REST API. All features of prodsys are also available in the API and allow easy integration of prodsys in operative IT architectures. </p> <p>The API is based on the FastAPI framework and utilizes the models API of prodsys. To use prodsys as a webserver, you can use the official docker image which can be obtained from dockerhub:</p> <pre><code>docker pull sebbehrendt/prodsys\n</code></pre> <p>To start the API, run the following command:</p> <pre><code>docker run -p 8000:8000 sebbehrendt/prodsys\n</code></pre> <p>The API documentation is then available at <code>http://localhost:8000/docs</code>. </p>"},{"location":"#contributing","title":"Contributing","text":"<p><code>prodsys</code> is a new project and has therefore much room for improvement. Therefore, it would be a pleasure to get feedback or support! If you want to contribute to the package, either create issues on prodsys' github page for discussing new features or contact me directly via github or email.</p>"},{"location":"#license","title":"License","text":"<p>The package is licensed under the MIT license.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We extend our sincere thanks to the German Federal Ministry for Economic Affairs and Climate Action (BMWK) for supporting this research project 13IK001ZF \u201cSoftware-Defined Manufacturing for the automotive and supplying industry  https://www.sdm4fzi.de/\u201d.</p>"},{"location":"API_reference/API_reference_0_overview/","title":"API reference overview","text":"<p>This section contains the API reference for <code>prodsys</code>. The following modules are available:</p> <ul> <li>Models API</li> <li>Adapter</li> <li>Express API</li> <li>Factories</li> <li>Simulation</li> <li>Optimization</li> <li>Control</li> <li>Utils</li> </ul>"},{"location":"API_reference/API_reference_1_Models_API/","title":"prodsys Models API","text":"<p>The <code>prodsys.models</code> package contains the data structures to describe a production system's structure and its performance. These data structures are utilized in prodsys to have a common format for all algorithms in simulation, optimization, analysis and the prodsys webserver. All of these formats are compatible with the <code>prodsys.express</code> API. However, the conversion works only in one direction: from <code>prodsys.express</code> to <code>prodsys.models</code>. </p> <p>The following modules are available:</p> <ul> <li><code>prodsys.models.core_asset</code>: Contains the abstract base class for data objects.</li> <li><code>prodsys.models.product_data</code>: Contains classes to represent products.</li> <li><code>prodsys.models.performance_data</code>: Contains classes to represent performance data.</li> <li><code>prodsys.models.performance_indicators</code>: Contains classes to represent performance indicators (KPIs).</li> <li><code>prodsys.models.processes_data</code>: Contains classes to represent processes.</li> <li><code>prodsys.models.queue_data</code>: Contains classes to represent queues.</li> <li><code>prodsys.models.resource_data</code>: Contains classes to represent resources.</li> <li><code>prodsys.models.node_data</code>: Contains classes to represent nodes in a link.</li> <li><code>prodsys.models.scenario_data</code>: Contains classes to represent scenario data.</li> <li><code>prodsys.models.sink_data</code>: Contains classes to represent sinks.</li> <li><code>prodsys.models.source_data</code>: Contains classes to represent sources.</li> <li><code>prodsys.models.state_data</code>: Contains classes to represent states.</li> <li><code>prodsys.models.links_data</code>: Contains classes to represent links.</li> <li><code>prodsys.models.time_model_data</code>: Contains classes to represent time models.</li> </ul>"},{"location":"API_reference/API_reference_2_Adapter/","title":"Adapter","text":"<p>This module contains the adapters for the production system which are data containers for the data models defined in <code>prodsys.models</code>. The adapters are used in all algorithms that analyze or optimize a production system.  The data structure of the adapter can also be used to integrate new algorithms into prodsys by utilizing its defined data structure.  The adapters is the <code>prodsys.models</code> equivalent to the <code>prodsys.express.ProductionSystem</code> class and can be created from the express object. In contrast to the adapter, the express class nests the objects in a tree structure, which makes it easier to work with when instantiating a production system, but more complicated when reviewing the data itself. The adapter comes with a data validation that ensures that entered data is syntatically, semantically and logically valid.</p>"},{"location":"API_reference/API_reference_3_Express_API/","title":"prodsys Express API","text":"<p>This module contains the <code>prodsys.express</code> API with classes and functions to easily specify all parameters of a production system. This API is completely compatible with <code>prodsys.models</code> and every object can be converted to a data object from <code>prodsys.models</code> using the <code>to_model</code> method.</p> <p>The express API is more convenient to use than the <code>prodsys.models</code> API because the express API nests the objects in a tree structure, which makes it easier to work with when instantiating production system programatically. </p> <p>However, the express API does not support all features of the <code>prodsys.models</code> API and saved data is more complicated to review because of the nesting.</p> <p>Recommended is to use the API for programmatically specifying a production system but saving the data in the <code>prodsys.models</code> format with the <code>ProductionSystemAdapter</code>.</p> <p>The following modules are available:</p> <ul> <li><code>prodsys.express.core</code>: Contains the abstract base class for express objects. </li> <li><code>prodsys.express.product</code>: Contains classes to specify products.</li> <li><code>prodsys.express.process</code>: Contains classes to specify processes.</li> <li><code>prodsys.express.production_system</code>: Contains classes to specify a production system.</li> <li><code>prodsys.express.resources</code>: Contains classes to specify resources.</li> <li><code>prodsys.express.sink</code>: Contains classes to specify sinks.</li> <li><code>prodsys.express.source</code>: Contains classes to specify sources.</li> <li><code>prodsys.express.state</code>: Contains classes to specify states.</li> <li><code>prodsys.express.time_model</code>: Contains classes to specify time models.</li> </ul>"},{"location":"API_reference/API_reference_4_factories/","title":"Factories","text":"<p>The <code>prodsys.factories</code> package contains the factory classes to create <code>prodsys.simulation</code> objects from <code>prodsys.models</code> objects in order to initialize a simulation run.</p> <p>The following modules are available:</p> <ul> <li><code>prodsys.factories.product_factory</code>: Contains the factory class to create products.</li> <li><code>prodsys.factories.process_factory</code>: Contains the factory class to create processes.</li> <li><code>prodsys.factories.queue_factory</code>: Contains the factory class to create queues.</li> <li><code>prodsys.factories.resource_factory</code>: Contains the factory class to create resources.</li> <li><code>prodsys.factories.sink_factory</code>: Contains the factory class to create sinks.</li> <li><code>prodsys.factories.source_factory</code>: Contains the factory class to create sources.</li> <li><code>prodsys.factories.state_factory</code>: Contains the factory class to create states.</li> <li><code>prodsys.factories.time_model_factory</code>: Contains the factory class to create time models.</li> </ul>"},{"location":"API_reference/API_reference_5_Simulation/","title":"Simulation","text":"<p>This package contains the simulation module. It is based on the SimPy package and uses the <code>prodsys.models</code> API for running the simulation. Objects are created with the <code>prodsys.factories</code>.</p> <p>The simulation module contains the following modules:</p> <ul> <li><code>prodsys.simulation.control</code>: Contains the logic for controlling the processes of resources in the simulation.</li> <li><code>prodsys.simulation.logger</code>: Used for logging events in the simulation for later analysis.</li> <li><code>prodsys.simulation.observer</code>: Can be used to observe the simulation and its processes while simulation.</li> <li><code>prodsys.simulation.process_models</code>: Contains process models for products for the simulation.</li> <li><code>prodsys.simulation.process</code>: All processes used in the simulation for product processing or transport.</li> <li><code>prodsys.simulation.product</code>: Contains the logic for the product object in the simulation.</li> <li><code>prodsys.simulation.request</code>: Has classes for representing requests of products to resources for processing or transport.</li> <li><code>prodsys.simulation.resources</code>: Contains the logic for all resources in the simulation.</li> <li><code>prodsys.simulation.router</code>: Contains the logic for routing products in the simulation.</li> <li><code>prodsys.simulation.sim</code>: Simulation class for running the simulation.</li> <li><code>prodsys.simulation.sink</code>: Contains the logic for sinks in the simulation.</li> <li><code>prodsys.simulation.source</code>: Contains the logic for sources in the simulation.</li> <li><code>prodsys.simulation.state</code>: Contains the logic for the state of resources in the simulation.</li> <li><code>prodsys.simulation.store</code>: Contains the logic for product queues of resources in the simulation.</li> <li><code>prodsys.simulation.time_model</code>: Contains the logic for time models in the simulation.</li> </ul>"},{"location":"API_reference/API_reference_6_Optimization/","title":"Optimization","text":"<p>The <code>optimization</code> package of <code>prodsys</code> provides different optimization algorithms for configuration planning of production systems. </p> <p>In configuration planning, the goal is to find a configuration of a production system that maximizes a given objective function. The objective function is a function that maps a configuration to a real number. The configuration is a set of parameters that describe the production system. For example, the configuration of a production system could be the number of machines of a certain type. The objective function could be the output of the production system. The goal is then to find the configuration that maximizes the output. With <code>prodsys.optimization</code>, you can use the modelling capacities of  <code>prodsys.adapters</code> to specifiy configurations and optimize them according to a scenario and chosen degrees of freedom for optimization.</p> <p>The following degrees of freedom are supported and can be specified by the scenario data attribute <code>transformations</code>:</p> <ul> <li>Adding or removing production resources</li> <li>Adding or removing transport resources</li> <li>Adding or removing processes of a production resource</li> <li>Changing the position of production resources</li> <li>Moving processes between production resources</li> <li>Changing the control policy of a production resource</li> <li>Changing the control policy of a transport resource</li> <li>Changing the routing policy of product types</li> </ul> <p>The following algorithms are supported:</p> <ul> <li>Evolutionary Algorithms (NGSGA-II)</li> <li>Simulated Annealing</li> <li>Tabu Search</li> <li>Mathematical optimization (Gurobi, only a restricted set of degrees of freedom is supported)</li> </ul> <p>Whilst the mathematical optimization uses a mathematical model for evalutation of production system performance, the other algorithms use <code>prodsys.simulation</code> for evaluation. This allows these algorithms to consider more degrees of freedom and optimize according to multiple objectives.</p> <p>The following KPIs are supported for objectives in optimization with the simulation based optimization algorithms:</p> <ul> <li>Minimize the WIP (Work in Progress)</li> <li>Minimize the throughput time</li> <li>Minimize the reconfiguration cost considering capital expenditure (CAPEX)</li> <li>Maximize the output / throughput</li> </ul> <p>For a more detailed explanation on the algorithms, degrees of freedom and choice of objectives, please consider the following literature: Paper</p>"},{"location":"API_reference/API_reference_6_Optimization/#prodsys.optimization.VERBOSE","title":"<code>VERBOSE = 1</code>  <code>module-attribute</code>","text":"<p>The verbosity level of the optimization algorithms. The higher the level, the more information is printed to the console.</p>"},{"location":"API_reference/API_reference_7_Control/","title":"Control","text":""},{"location":"API_reference/API_reference_8_util/","title":"Util","text":"<p>Contains utility functions for the prodsys package.</p>"},{"location":"Tutorials/tutorial_0_overview/","title":"Tutorials overview","text":"<p>This section contains a series of tutorials that will guide you through the process of modelling and simulating a production system using <code>prodys</code>. The following tutorials are available:</p> <ul> <li>Tutorial 1: Modelling and simulating a production system</li> <li>Tutorial 2: Analyzing simulation results</li> <li>Tutorial 3: Optimizing a production system</li> <li>Tutorial 4: Optimizing production control</li> </ul> <p>All of the tutorials are also on the github page of prodsys in the examples folder as jupyter notebooks available, so that you can run them yourself.</p> <p>In the future, more tutorials will be added to this section. If you have any suggestions for new tutorials, please create an issue on prodsys' github page. For more information about the package's functionality, please see the API reference.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/","title":"Modelling a production system","text":"<p>In this example we explore the modeling functionalities of <code>prodsys</code>. In <code>prodsys</code> we model production systems be specifying the attributes of the following components:</p> <ul> <li>Time model: All relevant timely features of the production system.</li> <li>Processes: Processes give resources the capabilities to perform certain production or transport processes.</li> <li>Resources: Resources perform the production and transport processes.</li> <li>Products: The products that are produced in the production system, requiring a set of processes to be performed.</li> <li>Sources: Sources create products and place them in the production system.</li> <li>Sinks: Sinks store finished products.</li> <li>Production system: The production system is the container for all components and is used to run the simulation.</li> </ul> <p>To make these concepts more understandable, we extend the example from the getting started section. The production system contains a milling machine, a turning lath and a work center that perform processes on aluminium housings. The transport is thereby performed by a worker.</p> <p>We will start by importing the express API:</p> <pre><code>import prodsys.express as psx\n</code></pre> <p>Additionally, since the progress bar can be buggy sometimes in Jupyter notebooks, we can disable it for this example by setting the verbose level of the simulation to 0:</p> <pre><code>from prodsys.simulation import sim\n\nsim.VERBOSE = 0\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#time-models","title":"Time models","text":"<p><code>prodsys</code> provides different types of time models to use, the are:</p> <ul> <li>FunctionTimeModel: A time model that is based on a distribution function. Either constant, normal, lognormal or exponential.</li> <li>SampleTimeModel: A time model that is based on a sequence of time values that are randomly sampled.</li> <li>ScheduledTimeModel: A time model that is based on a schedule of time values. The schedule can contain relative or absulte time values. Also the schedule can be executed once or multiple times in a cycle.</li> <li>DistanceTimeMOdel: A time model that is based on th distance between two locations and a constant speed and reaction time. Manhattan distance or Euclidian distance can be used as distance metrics between the points.</li> </ul> <p>We will use the <code>FunctionTimeModel</code> to model the time required for milling and turning processes and model the time needed for transport with the <code>DistanceTimeModel</code>. We will also model the arrival of housings with the <code>ScheduledTimeModel</code>, which could, e.g. be observed inter-arrival times:</p> <pre><code>milling_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=1, scale=0.1, ID=\"milling_time\")\nturning_time = psx.FunctionTimeModel(distribution_function=\"normal\", location=0.5, scale=0.1, ID=\"turning_time\")\ntransport_time = psx.DistanceTimeModel(speed=200, reaction_time=0.05, metric=\"manhattan\", ID=\"transport_time\")\narrival_time_of_housing_1 = psx.ScheduledTimeModel([1.6, 1.3, 1.8, 2.0, 1.2, 1.7, 1.3], absolute=False, cyclic=True, ID=\"arrival_time_of_housings\")\narrival_time_of_housing_2 = psx.ScheduledTimeModel([1.3, 2.3, 2.1, 2.0, 1.4], absolute=False, cyclic=True, ID=\"arrival_time_of_housings\")\n</code></pre> <p>Note, the <code>ManhattanDistanceTimeModel</code> and the <code>SequentialTimeModel</code> are deprecated. The <code>ManhattanDistanceTimeModel</code> is replaced by the <code>DistanceTimeModel</code> and the <code>SequentialTimeModel</code> is replaced by the <code>SampleTimeModel</code>.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#processes","title":"Processes","text":"<p>After creating the time models, we can define the processes in the system. We will use the <code>ProductionProcess</code> to model the milling and turning processes and the <code>TransportProcess</code> to model the transport process:</p> <pre><code>milling_process = psx.ProductionProcess(milling_time, ID=\"milling_process\")\nturning_process = psx.ProductionProcess(turning_time, ID=\"turning_process\")\ntransport_process = psx.TransportProcess(transport_time, ID=\"transport_process\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#resources","title":"Resources","text":"<p>With this, we can create our resources. The milling machine and turning lath can perform their associated processes and the worker can perform the transport process. However, the work center can perform milling and turning. Milling machine, turning lath and work center are <code>ProductionResource</code>s and the worker is a <code>TransportResource</code>:</p> <pre><code>milling_machine = psx.ProductionResource([milling_process], location=[5, 5], ID=\"milling_machine\")\nturning_lath = psx.ProductionResource([turning_process], location=[10, 10], ID=\"turning_machine\")\nwork_center = psx.ProductionResource([milling_process, turning_process], location=[5, 10], ID=\"work_center\")\nworker = psx.TransportResource([transport_process], location=[0, 0], ID=\"worker\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#product","title":"Product","text":"<p>Now, with specified resources, we can model our product, the housing. In fact, we don't have only one housing but two different variants for this example. The first product requires milling and afterwards turning, and the second requries turning and afterwards milling:</p> <pre><code>housing_1 = psx.Product([milling_process, turning_process], transport_process, ID=\"housing_1\")\nhousing_2 = psx.Product([turning_process, milling_process], transport_process, ID=\"housing_2\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#sources-and-sinks","title":"Sources and sinks","text":"<p>At last, we need to model the sources and sinks. The source creates housings and places them in the production system. The sink stores finished housings:</p> <pre><code>source_1 = psx.Source(housing_1, arrival_time_of_housing_1, location=[0,0], ID=\"source_1\")\nsource_2 = psx.Source(housing_2, arrival_time_of_housing_2, location=[0, 1], ID=\"source_2\")\n\nsink_1 = psx.Sink(housing_1, location=[20, 20], ID=\"sink_1\")\nsink_2 = psx.Sink(housing_2, location=[20, 21], ID=\"sink_2\")\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#production-system-creation","title":"Production System creation","text":"<p>We now create the production system, validate it and run the simulation for 60 minutes. Afterwards, we print aggregated simulation results:</p> <pre><code>production_system = psx.ProductionSystem([milling_machine, turning_lath, work_center, worker], [source_1, source_2], [sink_1, sink_2])\nproduction_system.validate()\nproduction_system.run(60)\nproduction_system.runner.print_results()\n</code></pre> <p>By validating the production system, we can check if all components are valid and if the production system is consistent in a logical or physical sende. If the production system is not valid, the validation will raise an exception and the simulation cannot be run. However, it easily let's you identify where you made some modelling mistakes.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#states","title":"States","text":"<p>We can also add different states, such as setups and breakdowns, to resources to model their behavior more accurately. For example, we can add a setup and breakdown to the work center by specifying the time models for breakdown an setup, create states and add them to the work center:</p> <pre><code>breakdwon_time_model = psx.FunctionTimeModel(distribution_function=\"exponential\", location=200, ID=\"breakdown_time_model\")\nrepair_time_model = psx.FunctionTimeModel(distribution_function=\"exponential\", location=10, ID=\"repair_time_model\")\nsetup_time_model_1 = psx.FunctionTimeModel(distribution_function=\"exponential\", location=0.2, ID=\"setup_time_model\")\nsetup_time_model_2 = psx.FunctionTimeModel(distribution_function=\"exponential\", location=0.3, ID=\"setup_time_model\")\n\nbreakdown_state = psx.BreakDownState(breakdwon_time_model, repair_time_model, ID=\"breakdown_state\")\nsetup_state_1 = psx.SetupState(setup_time_model_1, milling_process, turning_process, ID=\"setup_state_1\")\nsetup_state_2 = psx.SetupState(setup_time_model_2, turning_process, milling_process, ID=\"setup_state_2\")\n\nwork_center.states = [breakdown_state, setup_state_1, setup_state_2]\n</code></pre> <p>Note, that we could have given these states to the resource already in the initialization. Again, we simulate the production system and evaluate its performance.</p> <pre><code>production_system.validate()\nproduction_system.run(60)\nproduction_system.runner.print_results()\n</code></pre> <p>The results show that the work center is now for some time in Setup (ST).  However, no time increment for unscheduled downtime due to breakdowns (UD) is visible. This is due to the limited simulation time. If we increase the simulation time to 1000 minutes, we can see that the work center is also in unscheduled downtime for some time:</p> <pre><code>production_system.validate()\nproduction_system.run(1000)\nproduction_system.runner.print_results()\n</code></pre> <p>Now we see, that the work center is 6.1% of the time unavailable due to unscheduled downtime.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#changing-the-logic-of-the-production-system","title":"Changing the logic of the production system","text":"<p><code>prodsys</code> does not only allow to change the physical configuration of a production system but also the logic. For example, we can change the logic of the work center by changing it's control policy from <code>FIFO</code> (first in first out) to <code>SPT</code> (shortes process time first). BY changing this, the work center will now get products from the queue with bias on the short process, which is in our case the turning process:</p> <pre><code>from prodsys.models.resource_data import ResourceControlPolicy\n\nwork_center.control_policy = ResourceControlPolicy.SPT\n\nproduction_system.validate()\nproduction_system.run(1000)\nproduction_system.runner.print_results()\n</code></pre> <p>Additionally, we can change the routing policy in the production system. A routing policy is not used for heuristically solving a sequencing problem as the control policy but for solving the routing problem for parallel redundant resources. In our example, bot milling machine and work center provide the milling process. While simulating, we need to have some logic how to decide which product is processed on which resource. By default, the routing policy is <code>random</code>, which means that the routing is randomly chosen. However, we can also change the routing policy to <code>shortest_queue</code>, which means that the product is always routed to the resource with the shortest queue:</p> <pre><code>from prodsys.models.source_data import RoutingHeuristic\n\nsource_1.routing_heuristic = RoutingHeuristic.shortest_queue\n\nproduction_system.validate()\nproduction_system.run(1000)\nproduction_system.runner.print_results()\n</code></pre>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#prodsysmodels-api","title":"prodsys.models API","text":"<p>So far, we only studied the express API of <code>prodsys</code>. However, <code>prodsys</code> also provides a more detailed API that allows to model more complex production systems with <code>prodsys.models</code>. The models API uses ID references for connecting the different entities (processes, products, resources etc.) that results in a flat data structure instead of nested hierarchical relationsship, as the express API. Whilst the hierarchical structure is easy for programmatically creating production systems, the flat data structure is more convenient for serializing the data, i.e. saving and loading production systems. All algorithms in <code>prodsys</code> use the models API. For luck, all express API objects can be converted to models API objects and vice versa.</p> <pre><code>model_production_system = production_system.to_model()\nprint(model_production_system.process_data[0])\n</code></pre> <p>For now, the express API allows all modeling features as the models API but the creation of products that require processes in a sequence according to an assembly precedence graph. This feature is only available in the models API. For more information, refer to the API reference in the documentation. However, using the algorithms provided by <code>prodsys</code> for optimizing or autonomously controlling a production system requires the models API. For a complete overview of the package's modelling functionalities, please see the API reference.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#advanced-modeling-features","title":"Advanced modeling features","text":""},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#capability-processes","title":"Capability Processes","text":"<p><code>prodsys</code> also provides the possibility for a <code>CapabilityProcess</code> instead of normal <code>ProductionProcess</code>. These processes are not matched by their ID but by their capability, which gives more flexibility in modeling the operations of a production system. </p> <p>The capabilities extends the typical PPR modeling principle (Product, Process and Resource) of <code>prodsys</code> to the Product, Process, Resource and Skill modelling principle PPRS by considering the capabilities / skills required for performing processes. </p> <p>One typical use case where this capability-based modeling is useful is when a product requires a certain process but multiple resources can perform this process with different speeds or capacity.</p> <p>In prodsys, we can realize this by specifying with a <code>RequiredCapabilityProcess</code> for a product which kind of capabilities are required for its production. Additionally, we define multiple different <code>CapabilityProcess</code> for resources that satisfy the capability and therefore can perform the process on the prodct. During simulation, processes of resources are matchedto the required processes based on a comparison of the capability attribute. </p> <p>For example, we could define the following case, where a turning process is required by a product and two machines are available that can perform this process, but with different speeds:</p> <pre><code>import prodsys.express as psx\nfrom prodsys.express import production_system\n\ntime_model_agv = psx.DistanceTimeModel(speed=90, reaction_time=0.2, ID=\"time_model_x\")\ntransport_process = psx.TransportProcess(\n    time_model=time_model_agv, ID=\"transport_process\"\n)\nagv = psx.TransportResource(ID=\"agv\", processes=[transport_process], location=[5, 5])\n\ntime_model_turning_fast = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=6, ID=\"time_model_turning_fast\"\n)\ntime_model_turning_slow = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=9, ID=\"time_model_turning_slow\"\n)\n\ncapability_process_turning_fast = psx.CapabilityProcess(\n    time_model=time_model_turning_fast, capability=\"turning\", ID=\"cp_turning_fast\"\n)\ncapability_process_turning_slow = psx.CapabilityProcess(\n    time_model=time_model_turning_slow, capability=\"turning\", ID=\"cp_turning_slow\"\n)\n\nresource_fast = psx.ProductionResource(\n    ID=\"resource_fast\", processes=[capability_process_turning_fast], location=[5, 0]\n)\nresource_slow = psx.ProductionResource(\n    ID=\"resource_slow\", processes=[capability_process_turning_slow], location=[5, 10]\n)\n\nrequired_capability_process_turning = psx.RequiredCapabilityProcess(\n    capability=\"turning\", ID=\"rcp_turning\"\n)\n\nproduct = psx.Product(\n    processes=[required_capability_process_turning],\n    transport_process=transport_process,\n    ID=\"product\",\n)\n\nsource = psx.Source(\n    time_model=psx.FunctionTimeModel(\n        distribution_function=\"constant\", location=6, ID=\"interarrival_time_model\"\n    ),\n    ID=\"source\",\n    product=product,\n    location=[0, 5],\n)\n\nsink = psx.Sink(ID=\"sink\", product=product, location=[10, 5])\n\nsystem = production_system.ProductionSystem(\n    resources=[resource_fast, resource_slow, agv], sources=[source], sinks=[sink]\n)\n\nsystem.validate()\nsystem.run(1000)\nsystem.runner.print_results()\n</code></pre> <p>In this example, we model the <code>RequiredCapabilityProcess</code> of the product by stating, it requires the capability \"turning\":</p> <pre><code>required_capability_process_turning = psx.RequiredCapabilityProcess(\n    capability=\"turning\", ID=\"rcp_turning\"\n)\nproduct = psx.Product(\n    processes=[required_capability_process_turning],\n    transport_process=transport_process,\n    ID=\"product\",\n)\n</code></pre> <p>Of course, we could extend the process sequence of the product with other processes, both CapabilityProcesses and normal processes.</p> <p>To specify that two resources can perform this process with different speed, we define two time models, two <code>CapabilityProcess</code> with the capability \"turning\" and two <code>ProductionResource</code>s with the processes:</p> <pre><code>time_model_turning_fast = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=6, ID=\"time_model_turning_fast\"\n)\ntime_model_turning_slow = psx.FunctionTimeModel(\n    distribution_function=\"constant\", location=9, ID=\"time_model_turning_slow\"\n)\ncapability_process_turning_fast = psx.CapabilityProcess(\n    time_model=time_model_turning_fast, capability=\"turning\", ID=\"cp_turning_fast\"\n)\ncapability_process_turning_slow = psx.CapabilityProcess(\n    time_model=time_model_turning_slow, capability=\"turning\", ID=\"cp_turning_slow\"\n)\n\nresource_fast = psx.ProductionResource(\n    ID=\"resource_fast\", processes=[capability_process_turning_fast], location=[5, 0]\n)\nresource_slow = psx.ProductionResource(\n    ID=\"resource_slow\", processes=[capability_process_turning_slow], location=[5, 10]\n)\n</code></pre> <p>With this, we can achieve that the product is processed on both machines, but with different speeds.</p> <p>Moreover, there also exists a <code>LinkTransportProcess</code> which allows to define that a transport process can only be performed between certain resources. This allows to make transport in <code>prodsys</code> more realistic. </p> <p>For more information, refer to the API reference in the documentation or checkout the examples folder of <code>prodsys</code>.</p>"},{"location":"Tutorials/tutorial_1_modelling_and_simulating_a_production_system/#further-modeling-concepts","title":"Further modeling concepts","text":"<p>For more complex use cases that need to consider more aspects of a real production system, prodsys contains some handy features. Modeling concepts that are not yet described in the tutorial are:</p> <ul> <li>Queues and Storages: If you need to specifically restrict the size of resources queues or storages that contain products, you can manually define them with the <code>Queue</code>. The queues can be placed at different locations in the production system.</li> <li>Nodes and Links: If you need to model a more complex production system with multiple locations and transport routes, you can use the <code>Node</code> class to define the locations and create links with a <code>LinkTransportProcess</code>.</li> <li>Auxiliaries: If some processes require supportive material (e.g. work piece carriers or tools), you can define them with the <code>Auxiliary</code> class. The auxiliaries can be used to model the transport of supportive material. </li> </ul> <p>Additionally, prodsys provides the possibility to define your own policies that control the decision making in the production system. With this you can integrate your own logic. The policies are: - Routing Policies: You can create a function that orders a list of requests that contain all possibilities for routing a product to possible resources. Index 0 of the list is the first choice, index 1 the second choice and so on. The routing policy can be used to define the routing of products to resources. - Control Policies: You can create a function that orders a list of requests that contain all possibilities for processing a product on a resource. Index 0 of the list is the first choice, index 1 the second choice and so on. The control policy can be used to define the sequence of processing of products on resources.</p> <p>You can extended the default policies of prodsys by creating your own policies. For more information, refer to the API reference in the documentation or checkout the examples folder of prodsys. For more hands-on experience, you can also check out the examples in the prodsys modeling and simulation examples folder.</p>"},{"location":"Tutorials/tutorial_2_analyzing_simulation_results/","title":"Analyzing simulation results","text":"<p>In the following tutorial, we will explore the analysis capabilities of <code>prodsys</code> for examining simulation results. In <code>prodsys</code>, every single of a simulation run get's tracked and logged, thus allowing to review the complete event log of a simulation run, as in the real world. Similarly, all KPIs can be calculated in the post processing. This allows for a very flexible analysis of the simulation results. <code>prodsys</code> allready provides many utility functions for calculating KPIs and plotting the results. In this tutorial, we will explore some of them.</p> <p>For this example, we will use another production system which we will load from a json-file (example_configuration.json), which can be found in the examples folder of prodsys' github page. Download it and store it in the same folder as this notebook. Load the configuration and run a simulation with the following commands:</p> <pre><code>import prodsys\n\nproduction_system = prodsys.adapters.JsonProductionSystemAdapter()\nproduction_system.read_data('example_configuration.json')\n\nrunner = prodsys.runner.Runner(adapter=production_system)\nrunner.initialize_simulation()\nrunner.run(20000)\nrunner.print_results()\n</code></pre> <p>When reviewing the simulation results, we will see that the production system consists of 4 prudction resources (R1, R2, R3, R4) and two transport resources (TR1, TR2). Additionally, we see that three different kind of products are produced (product_1, product_2, product_3). When reviewing the KPIs, there doesn't seem to be any problems with the production system. However, this is hard to tell without knowing something about the production system and we will see that there are some problems with the production system, which we will explore in the following.</p> <p>The basic data structure used for logging all events can be accessed by the <code>EventLogger</code> class, which is an attribute of the runner. The logger stores this data in form of dictionaries but we can transform it to a pandas dataframe for more convenient analysis:</p> <pre><code>df = runner.event_logger.get_data_as_dataframe()\ndf.head(10)\n</code></pre> <p>If we have a look at the dataframe, we will see that it contains 8 columns to describe each event:</p> <ul> <li>Time: The time of the event</li> <li>Resource: The resource on which the event occured</li> <li>State: The state of the resource that changed</li> <li>State Type: The type of the state that changed (e.g. source, transport, breakdwon, etc.)</li> <li>Activity: The activity that was performed</li> <li>Product: The product that was processed or transported (only for Production or Transport states)</li> <li>Expected End Time: The expected end time of the state</li> <li>Target location: The target location of a transport (only for Transport states)</li> </ul> <p>Writing scripts that analysis these event logs can be tydious. We can use powerfull process mining tools to automate the analysis of these event logs to analysis all processes, event durations and so on. However, in this tutorial, we will focus on the analysis of the KPIs. For this, we will use the <code>PostProcessor</code> class, which can be obtained from runner. The <code>PostProcessor</code> class provides many utility functions for calculating KPIs and plotting the results. In this tutorial, we will explore some of them. Let's get a <code>PostProcessor</code> from the runner and have a look at the KPIs:</p> <pre><code>post_processor = runner.get_post_processor()\nprint(\"Throughput per product type:\", post_processor.get_aggregated_throughput_data())\nprint(\"WIP per product type:\", post_processor.get_aggregated_wip_data())\nprint(\"Throughput time per product type:\", post_processor.get_aggregated_throughput_time_data())\n</code></pre> <p><code>prodsys</code> also provides some models for KPIs which can be used more easily in algorithms. For example, we can use the <code>WIP_KPIs</code>property to calculate the KPI values of the production system:</p> <pre><code>for wip_kpi in post_processor.WIP_KPIs:\n    print(\"WIP KPI:\", wip_kpi)\n    print(\"WIP KPI value:\", wip_kpi.value)\n</code></pre> <p>The <code>PostProcessor</code> has some pre-processed data frames, which can be used for custom analyis. For example, we can get a data frame with only products that have been finished during the simulation run:</p> <pre><code>post_processor.df_finished_product.head()\n</code></pre> <p>However, most easiest or fastest method for analysing simulation results is using the plotting functionalities of <code>prodsys</code>. These can be accesses through the <code>kpi_visualization</code> and only require a <code>PostProcessor</code> for instantiation. For example, we can plot the time percentages of resources in different states:</p> <pre><code>from prodsys.util import kpi_visualization\n\nkpi_visualization.plot_time_per_state_of_resources(post_processor)\n</code></pre> <p>We can observe, that the resources in the production system are not really heavily utilized, since their productive (PR) percentage is lower than 50% for all resources but R2. Let's plot the WIP KPI and see if this aligns with our first observations:</p> <pre><code>from prodsys.util import kpi_visualization\n\nkpi_visualization.plot_WIP(post_processor)\n</code></pre> <p>We can see that the production system has at first a stable WIP at around a total of 7 but at roughly 5000 minutes, the WIP starts increasing and does not stabilize anymore. This suggest, that our system is running very full with semi-finished material. We can look more closely at the WIP when considering the WIP at the different resources over time:</p> <pre><code>kpi_visualization.plot_WIP_per_resource(post_processor)\n</code></pre> <p>When observing the WIP per resource, we can observe that WIP at the resources increase steadily until ca. 15500 minutes. Then, suddenly, the WIP curve stops. This is a strong indicator that a Deadlock occured, where all positions of the queues are full and transports are blocked, because their target is blocked. This, is caused as products can have re-entrant flow in this example, thus blocking each other. Let's also look at the throughput time of the products:</p> <pre><code>kpi_visualization.plot_throughput_time_over_time(post_processor)\n</code></pre> <p>Again, we see a divergence of throughput time over simualted time. Here, the Start_time relates to the start of production of a product, i.e. the creation at it's source. These observations suggest, that the system is running to a WIP level which cannot be processed efficiently, similar to a crowded parking space after an event. If we take a look at the queue's of the system and the capacity of production resources, we can determine the maximal number of products in the system:</p> <pre><code>capacity = 0\nfor resource in production_system.resource_data:\n    capacity += resource.capacity\n\nfor queue in production_system.queue_data:\n    capacity += queue.capacity\n\nprint(capacity)\n</code></pre> <p>We see, that at maximum 69 products can be in the production system in parallel. However, when we examine the queues more in detail, we see, that some resource share also queues (R3 and R4):</p> <pre><code>machines = prodsys.adapters.get_machines(production_system)\nfor machine in machines:\n    print(machine.ID, machine.input_queues, machine.output_queues)\n</code></pre> <p>Let's investigate if the production system's storage capacity for products is too low that there is some blocking or if the production system's throughput is not high enough for the arrival processes. To do this, we test how the WIP changes if we make the queues of the production system unlimited (capacity=0).</p> <pre><code>adjusted_production_system = production_system.copy(deep=True)\n\nfor queue in adjusted_production_system.queue_data:\n    queue.capacity = 0\n\nrunner = prodsys.runner.Runner(adapter=adjusted_production_system)\nrunner.initialize_simulation()\nrunner.run(20000)\nnew_post_processor = runner.get_post_processor()\nkpi_visualization.plot_WIP(new_post_processor)\n</code></pre> <p>If we look at the results again, we see that the production system WIP increases not as strong as without limited queues. This suggests that both cases were True. At first, the production system got fuller without limited queues which suggest that some queues overflowed when limited causing some blocking. Additionally, we see that the WIP still increases over time, thus the production system requires more resources or another configuration to satisfy the arrival processes. <code>prodsys</code> provides also some functionality to optimize production system configuration. See the optimization example for more detailed information. For a complete overview of the package's ies for simulation analysis, please see the API reference.</p>"},{"location":"Tutorials/tutorial_3_optimizing_a_production_system/","title":"Optimizing a production system","text":"<p>This tutorial will guide you through the optimization functionalities of <code>prodsys</code> to optimize the configuration of a production system. With the <code>prodsys.optimization</code> package, we can utilize meta-heuristics and mathematical optimization for this task. All algorithms can be conviently used with the <code>prodsys.models</code> API.</p> <p>For this example, we will use a production system which we will load from a json-file (base_configuration.json), which can be found in the examples folder of prodsys' github page. Download it and store it in the same folder as this notebook. Load the configuration and run a simulation with the following commands:</p> <pre><code>import prodsys\nfrom prodsys.simulation import sim\nsim.VERBOSE = 0\n\nproduction_system = prodsys.adapters.JsonProductionSystemAdapter()\nproduction_system.read_data('base_configuration.json')\n\nprodsys.adapters.add_default_queues_to_adapter(production_system)\n\nrunner = prodsys.runner.Runner(adapter=production_system)\nrunner.initialize_simulation()\nrunner.run(2880)\nrunner.print_results()\n</code></pre> <p>As already concluded in the seccond tutorial, production system configurations can be suboptimal for a certain load of products. In this example, we also see that resoures M2, M3, M4 are very heavily utilized, whereas resource M1 has only a productivy of 34.4%. In order to satify the product needs of our customers and to balance the load on the resources more evenly, we want to find a more suitable configuration with the <code>prodsys.optimization</code> package. However, for starting optimization, we also need to provide an optimization scenario, that models constraints, options, information and the objectives. Let's start by creating the constraints of the scenario with the <code>prodsys.models</code> API:</p> <pre><code>from prodsys.models import scenario_data\n\nconstraints = scenario_data.ScenarioConstrainsData(\n    max_reconfiguration_cost=100000,\n    max_num_machines=8,\n    max_num_processes_per_machine=3,\n    max_num_transport_resources=2\n)\n</code></pre> <p>As you can see, the constraints consist of the maximum cost for reconfigruation and the maximumm number of machines, processes per machine and transport resources. Next, we define the options of our scenario for optimization:</p> <pre><code>positions = [[x*4, y*4] for x in range(4) for y in range(10)]\noptions = scenario_data.ScenarioOptionsData(\n    transformations=[scenario_data.ReconfigurationEnum.PRODUCTION_CAPACITY],\n    machine_controllers=[\"FIFO\", \"SPT\"],\n    transport_controllers=[\"FIFO\", \"SPT_transport\"],\n    routing_heuristics=[\"shortest_queue\"],\n    positions=positions\n)\n</code></pre> <p>We specify in the scenario options the transformations that can be performed by the optimizer, which control policies and routing heuristics are available and what kind of positions are available to place resources. By choosing the transformation <code>PRODUCTION_CAPACITY</code>, the optimizer can add, remove or move production resources from the system or processes from single production resources.</p> <p>At last, we need to specify our info for optimization:</p> <pre><code>info = scenario_data.ScenarioInfoData(\n    machine_cost=40000,\n    transport_resource_cost=20000,\n    process_module_cost=4000,\n    time_range=24*60\n)\n</code></pre> <p>The scenario info contains information about the cost for machines, transport resources and process modules. Additionally, we specify a time range. This value is the time used for evalutation of created configurations during simulation. Since many evaluations are performed during optimization, this parameter can significantly influence the optimmization Time. For now, we specified it to one day. Lastly we can define the objectives used for optimization:</p> <pre><code>from prodsys.models.performance_indicators import KPIEnum\nobjectives = [scenario_data.Objective(\n    name=KPIEnum.THROUGHPUT\n)]\n</code></pre> <p>Currently, only reconfiguration cost, throughput time, WIP and throughput can be optimized. Yet, similar logic can also be used for optimizing the productivity. With all this data defined, we can now create our optimization scenario and additionally add it to our production system:</p> <pre><code>scenario = scenario_data.ScenarioData(\n    constraints=constraints,\n    options=options,\n    info=info,\n    objectives=objectives\n)\nproduction_system.scenario_data = scenario\n</code></pre> <p>Instead of calling the optimization algorithms directly, we use the Optimizer class to manage the optimization process. This allows us to run different optimization algorithms within a unified interface while tracking optimization progress in real-time. Next, we define the hyper parameters for our optimization. At first, we will use evolutionary algorithm for our optimization, because it allows parallelization. The hyper parameters for optimization are strongly problem dependant and need to be adjusted accordingly. For this example, we will use the following parameters and run the optimization for 10 generations. Note, that this can take some time...</p> <pre><code>from prodsys.optimization.evolutionary_algorithm import EvolutionaryAlgorithmHyperparameters\nfrom prodsys.optimization.optimizer import FileSystemSaveOptimizer\n\nhyper_parameters = EvolutionaryAlgorithmHyperparameters(\n    seed=0,\n    number_of_generations=10,\n    population_size=16,\n    mutation_rate=0.2,\n    crossover_rate=0.1,\n    number_of_seeds=1,\n    number_of_processes=1\n)\n#Create an optimizer instance\noptimizer = FileSystemSaveOptimizer(\n    adapter=production_system,\n    hyperparameters=hyper_parameters,\n    save_folder=\"optimization_results\",\n)\n#Run the optimization\noptimizer.optimize()\n</code></pre> <p>All algorithms in <code>prodsys</code> can be utilized with the same interface. Also available are the following algorithms:</p> <ul> <li><code>prodsys.optimization.simulated_annealing</code>: simulated annealing optimization for all transformations</li> <li><code>prodsys.optimization.tabu_search</code>: tabu search for all transformations</li> <li><code>prodsys.optimization.math_opt</code>: mathematical optimization with Gurobi, allows only optimization of the production capacity</li> </ul> <p>We see in the output, that the algorithm is running and that new best solutions with a higher performance are found. We can analyze them now and see, if we can find a better configuration for our production system. Optimization core results of the objective for the individual solutions and the solutions themselves are saved in the specified <code>optimization_results</code> folder to make sure that interruptions in optimization won't delete all results. We can load them with the following command and search for the best solution:</p> <pre><code>from prodsys.optimization import optimization_analysis\n\ndf = optimization_analysis.read_optimization_results_file_to_df(\"results/optimization_results.json\", \"evolutionary\")\ndf.sort_values(by=[\"agg_fitness\"], ascending=False).head()\n</code></pre> <p><code>prodsys</code> allows us to load the optimization results as a data frame and analyze them. For validation purposes, we simuate the best solution again and compare it to the initial solutions:</p> <pre><code>import os \n\n# Find all files i the result folder that contain the ID of the best individual\nbest_individual_ID = df.sort_values(by=[\"agg_fitness\"], ascending=False).head()[\"ID\"].values[0]\nbest_individual_ID = str(best_individual_ID)\nfiles = os.listdir(\"results\")\nfiles = [file for file in files if best_individual_ID in file]\nnew_production_system = prodsys.adapters.JsonProductionSystemAdapter()\nnew_production_system.read_data(\"results/\" + files[0])\n\nrunner = prodsys.runner.Runner(adapter=new_production_system)\nrunner.initialize_simulation()\nrunner.run(2880)\n\nrunner.print_results()\n</code></pre> <p>When comparing the results from the original production system and the new one, we see that two machines were added. However, the machines are still heavily utilized. Most likely, the optimizer did just not find a good solution, because we only ran it for 10 generations and for a small population size. Increasing these will take longer, but will more likely find better solutions.</p> <p>For a complete overview of the package's functionality, please see the API reference.</p>"},{"location":"Tutorials/tutorial_4_optimizing_production_control/","title":"Optimizing production control","text":"<p>This tutorial will guide you through the optimization functionalities of <code>prodsys</code> to optimize the production control in a production system. With the <code>prodsys.control</code> package, we can utilize reinforcement learning, a kind of machine learning, for this task. All algorithms can be conviently used with the <code>prodsys.models</code> API.</p> <p>For this example, we will use again a production system which we will load from a json-file (control_configuration.json), which can be found in the examples folder of prodsys' github page. It is the same example as in tutorial 2, but with lower arrival rates. Download it and store it in the same folder as this notebook. Load the configuration and run a simulation with the following commands:</p> <p>Let's start at first by loading our production system:</p> <pre><code>import prodsys\nfrom prodsys.simulation import sim\nsim.VERBOSE = 0\n\nproduction_system = prodsys.adapters.JsonProductionSystemAdapter()\nproduction_system.read_data('control_configuration.json')\n\nrunner = prodsys.runner.Runner(adapter=production_system)\nrunner.initialize_simulation()\nrunner.run(2880)\nrunner.print_results()\n</code></pre> <p>When reviewing the performance, we see that resource R2 has the highest productivity. In order to reduce WIP and improve overall performance, we want to optimize the production control concerning R2 with Reinforcement Learning. <code>prodsys.control</code> provides a convenient API to do so, by defining interfaces for training environments for RL agents for production control task. So far, the following elementary control tasks are considered:</p> <ul> <li>Sequencing: The agent has to decide for a resource which product to process next from a list of available products.</li> <li>Routing: The agent determines for a product which resource it processes next, given a list of possible resources to perform this process.</li> </ul> <p>In this tutorial, we will focus on the sequencing task. The routing task is similar and can be used analogously. Note that future versions of <code>prodsys.control</code> will provide more control tasks (e.g. such as product release control) and that it is also possible to define custom control tasks that are a combination of the existing ones.</p>"},{"location":"Tutorials/tutorial_4_optimizing_production_control/#the-training-environment-api","title":"The training environment API","text":"<p>When utilizing reinforcement learning for production control, we need to define a training environment for the RL agent. This environment is responsible for providing the agent with the current state of the production system and for executing the agent's actions. The environment is also responsible for providing the agent with a reward for each action. The gymnasium as RL-framework. The environments provided by <code>prodsys.control</code> are implemented as abstract base classes, specifying the methods that need to be implemented by the user for soving the associated control tasks. To realize a control environment, we need to implement a class that inherits from the abstract base classes and implements it's abstract methods:</p> <pre><code>from gymnasium import spaces\nimport numpy as np\nimport prodsys\nfrom prodsys.simulation import request\nfrom prodsys.control import sequencing_control_env\n\nclass ExampleControlEnv(sequencing_control_env.AbstractSequencingControlEnv):\n    def get_observation(self) -&gt; np.ndarray:\n        # Implement here function that returns the observation that fits to the observation space of the class instances.\n        pass\n\n    def get_info(self) -&gt; dict:\n        # Implement here function that returns a dictionary with information about the environment.\n        pass\n\n    def get_termination_condition(self) -&gt; bool:\n        # Implement here function that returns True if the simulation should be terminated, i.e. an episode ends.\n        pass\n\n    def get_reward(self, processed_request: request.Request, invalid_action: bool = False) -&gt; float:\n        # Implement here function that returns the reward for the current step.\n        pass\n</code></pre> <p>So, only 4 functions have to implemented to start training an RL-agent. These functions define the most critical aspects when training an RL-agent, which makes these environments especially easy to experiment with different RL-agent setups and compare them. Simulation interactions are handled by the environment, so that the user can focus on the RL-agent.</p> <p>Especially definitions of observations and rewards are critical for the performance of the agent. The following sections will show an exemplary implementation of the environment for the sequencing task.</p>"},{"location":"Tutorials/tutorial_4_optimizing_production_control/#example-implementation-of-a-sequencing-environment","title":"Example implementation of a sequencing environment","text":"<p>In this example, we will implement the training environment for an RL-agent that determines the sequence of performed processes for the production resource R2 from the example above.</p> <p>For a simple optimization of performed processes, we want that the RL-agent can observe all running processes and all upcoming processes from the queue. We want to motivate the agent to sequence in a way, that the WIP is low and as few as little setups are performed, since this lower throughput.</p> <p>To do so, we define the observation space, to be a binary tensor of shape CxP, where C is the number of possible running processes and the number of slots in the input queue of the resource and P is the number of possible processes. This tensor shows then which slot from resource or queue is taken by which process type.</p> <p>The reward will be defined by a stepwise reward and a sparse reward:</p> <ul> <li>Stepwise reward: The agent receives a reward of -1 if he selects an invalid action, 1 if he selects a valid action which requires not setup and 0 otherwise.</li> <li>Sparse reward: The agent receives a reward based on the difference of queue capacity and WIP at the resource.</li> </ul> <p>Lastly, termination is defined by 100k minutes passed in simulation time and the info is just a placeholder.</p> <p>The following code shows the implementation of the environment:</p> <pre><code>class ProductionControlEnv(sequencing_control_env.AbstractSequencingControlEnv):\n    def get_observation(self) -&gt; np.ndarray:\n        \"\"\"\n        Function that utilizes the ResourceObserver of the environment class to get an array of observations of processes performed by the resource and in the queue of the resource. The observatino has a dimension CxP, where c is the capacity of resource and queue and P the number of processes.\n\n        Returns:\n            np.ndarray: The observation.\n        \"\"\"\n        processes_observation = self.observer.observe_processes()\n        encoded_processes = []\n        processes = self.resource.data.process_ids\n\n        for process_observation in processes_observation:\n            encoded_process = [0 for _ in range(len(processes))]\n            encoded_process[processes.index(process_observation.process)] = 1\n            encoded_processes.append(encoded_process)\n\n        encoded_process = [0 for _ in range(len(processes))]\n        encoded_processes += [encoded_process] * (\n            self.resource.data.capacity - len(processes_observation)\n        )\n\n        queue_observations = self.observer.observe_input_queue()\n        for queue_observation in queue_observations:\n            encoded_process = [0 for _ in range(len(processes))]\n            encoded_process[processes.index(queue_observation.process)] = 1\n            encoded_processes.append(encoded_process)\n\n        encoded_process = [0 for _ in range(len(processes))]\n        queue_capacity = self.resource.input_queues[0].capacity\n        encoded_processes += [encoded_process] * (\n            queue_capacity - len(queue_observations)\n        )\n\n        return np.array(encoded_processes)\n\n    def get_info(self) -&gt; dict:\n        return {\"info\": 0}\n\n\n    def get_termination_condition(self) -&gt; bool:\n        return self.runner.env.now &gt;= 100000\n\n    def get_reward(self, processed_request: request.Request, invalid_action: bool = False) -&gt; float:\n        if invalid_action:\n            reward = -1\n        else:\n            reward = (\n                self.resource.current_setup is None\n                or processed_request.process.process_data.ID\n                == self.resource.current_setup.process_data.ID\n            )\n        if self.step_count % 10 == 0:\n            reward += self.resource.input_queues[0].capacity - len(self.resource_controller.requests) \n\n        return reward\n</code></pre> <p>Note that we utillize the observer, which is an attribute of the environment. The observer brings handy functions to observe the current state of a resource in the simulation.</p> <p>In order to validate that this environment works, we will at first use just random samping as a agent and step through it. At first, we we define the observation and action space since these are required by the environment and need to fit to our get_observation function:</p> <pre><code>resource_id = \"R2\"\nresource_data = [r for r in production_system.resource_data if r.ID == resource_id][0]\nqueue = [q for q in production_system.queue_data if q.ID == resource_data.input_queues[0]][0]\nshape = (queue.capacity + resource_data.capacity, len(resource_data.process_ids))\nobservation_space = spaces.Box(0, 1, shape=shape, dtype=int)\naction_space = spaces.Box(0, 1, shape=(queue.capacity,), dtype=float)\n</code></pre> <p>Now, we can create an instance of the environment and step through it:</p> <pre><code>env = ProductionControlEnv(production_system, \"R2\", observation_space=observation_space, action_space=action_space, render_mode=\"human\")\nobservation, info = env.reset(seed=42)\nfor step in range(20):\n   action = env.action_space.sample()  # this is where you would insert your policy\n   observation, reward, terminated, truncated, info = env.step(action)\n   print(f\"Step: {step} with a reward of {reward}\")\n\n   if terminated or truncated:\n      observation, info = env.reset()\nenv.close()\n</code></pre> <p>Lastly, we want to use a PPO RL-agent from stable-baselines3 to train the environment. We will use the default hyperparameters for the agent and train it for 20k steps. The following code shows the training:</p> <pre><code>import os\nimport time\nfrom stable_baselines3 import PPO\nfrom stable_baselines3.common.logger import configure\n\ntmp_path = os.getcwd() + \"\\\\tensorboard_log\\\\sequencing\\\\\" + time.strftime(\"%Y%m%d-%H%M%S\")\nnew_logger = configure(tmp_path, [\"stdout\", \"csv\", \"tensorboard\"])\n\nmodel = PPO(env=env, policy='MlpPolicy', verbose=1)\nmodel.set_logger(new_logger)\nmodel.learn(total_timesteps=20000)\n</code></pre> <p>You can review the training progress by looking at the tensorboard logs in the folder <code>tensorboard_log\\sequencing</code> in the current working directory. The following code will show the tensorboard logs in the notebook:</p> <pre><code>tensorboard --logdir tensorboard_log\\sequencing\n</code></pre> <p>This example should only show the required implementation for an RL-agent for production control tasks. The routing control task can be implemented in a similar fashion. For more information on the implementation of the environment, please refer to the documentation of the abstract base classes in the API reference of <code>prodsys.control</code>.</p>"}]}